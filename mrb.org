#+TITLE: Emacs configuration
#+DESCRIPTION: An org-babel based emacs configuration
#+LANGUAGE:  en
#+PROPERTY: results silent
* Emacs configuration
This is my emacs configuration file that is loaded with
=org-babel-load-file= in the Emacs init file. The intent is to have as
much of my Emacs configuration in here as possible. The system works
as a literal programming system where with a tangle the elisp code
that actually makes up my configuration is extracted automatically
and loaded.

This file was created from many separate elisp files and has not been
fully sanitized yet. Following the history of that may be interesting
to some as well. On top of that I have an auto commit hook on save
running at the moment which does not produce the best hitory
records. All that will change over time.

** Preparing for lift-off
The base of the emacs configuration is in the =~/.emacs.d/= directory,
so add this to my loadpaths first and give it a name.
#+BEGIN_SRC emacs-lisp
(setq emacs-directory "~/.emacs.d/")
(add-to-list 'load-path emacs-directory)
#+END_SRC

The first thing I want to take care of is to make customizations
possible and stored in a place to my liking. I want to load this
first so anything in the configuration I define explicitly overrides
it.
#+BEGIN_SRC emacs-lisp
(setq custom-file (concat emacs-directory "custom.el"))
(load custom-file)
#+END_SRC

Now that we have the locations of the configuration determined, I want
a way to have them forcibly compiled.
#+BEGIN_SRC emacs-lisp
  (defun mrb/compile-config ()
    (interactive)
    (org-babel-load-file (concat emacs-directory "mrb.org"))
    (byte-recompile-directory emacs-directory 0)
  )
#+END_SRC

Most of the time the editting process starts at the command
line. Because I use emacs in server mode, this needs a little script.
The script does two things:
1. check if we already have the emacs server, if not, start it;
2. treat input from stdin a little bit special.

And edit the file obviously.

#+BEGIN_SRC sh sh :exports code :tangle ~/bin/edit :shebang #!/bin/bash
#set -x

# This is an improved version of my edit script. The original one is
# still available as edit.old. This one does not use any window
# manager trickery to see if the daemon is already there. This one
# just starts it if it is not already there.
#
# TODO: see if we can have some output when the daemon is not there,
# it is now very silent
# TODO: there is a mention of server-visit-hook not running when no
# file is passed in in edit.old. I have not seen any ill effects, so
# left that out
#
# This script starts emacs daemon if it is not running, opens whatever file
# you pass in and changes the focus to emacs.  Without any arguments, it just
# opens the current buffer or *scratch* if nothing else is open.
EMACSCLIENT="/usr/local/bin/emacsclient --quiet --no-wait"

# Number of current visible frames,
# Emacs daemon always has a visible frame called F1
visible_frames() {
  $EMACSCLIENT --alternate-editor="" --eval '(length (visible-frame-list))' 2>/dev/null
}

change_focus() {
  $EMACSCLIENT --eval "(select-frame-set-input-focus (selected-frame))" > /dev/null
}

# Editting stdin, part 1: save the input to a file
save_stdin() {
    TMPSTDIN="$(mktemp /tmp/emacsstdinXXX)";
    cat >"$TMPSTDIN";
}

# if the file argument is '-', treat this as stdin
# TODO: pass $@ further down?
if [ $1 == "-" ]; then
    save_stdin
    # Recursive call!
    edit $TMPSTDIN;
    rm $TMPSTDIN;
    exit 0;
fi

# try switching to the frame incase it is just minimized
# This will start a server if not running
test "$(visible_frames)" -eq "1" && change_focus

if [ "$(visible_frames)" -lt  "2" ]; then
    # need to create a frame
    # -c $@ with no args just opens the scratch buffer
    $EMACSCLIENT --create-frame "$@" && change_focus
else
    # there is already a visible frame besides the daemon, change focus
    # -n $@ errors if there are no args
    test  "$#" -ne "0" && $EMACSCLIENT "$@"
fi
#+END_SRC

** Personal information
I'd like to arrange 3 things related to personal information:
1. register the proper identification to use;
2. Make sure the proper authentication information is stored;
3. Store this information privately.

So, identification, authorisation and encryption.

Seems like a good idea to start configuration with some details
about me. Just name and email-address for now in public. I don't think
there is anything else that needs to be public at the moment.
#+BEGIN_SRC emacs-lisp
  (setq user-full-name    "Marcel van der Boom")
  (setq user-mail-address "marcel@hsdev.com")
#+END_SRC


*** Authorization
Several things I use within Emacs need autorization, such as tramp,
jabber, erc etc. The authorization can come from several sources;
ideally as few as possible. Many packages in Emacs have support for a
=.netrc= like mechanism, others want to use the keyring in GNOME. The
variables =auth-sources= defines the sources available.

I want to use systems which are desktop independent, so things like
the gnome keyring are out because they depend on the gnome environment
being present, which I can not guarantee, nor want to related to
authentication. The situation which I want to prevent is that if gnome
is broken, I can't authenticate to services I need.

I have a gpg-agent daemon configured which manages gpg and ssh keys,
protected by one password. Let's make the system as simple as we can
for now and just store passwords in the gpg agent store only,
i.e. authinfo.gpg using public key encryption aimed at my key.

#+BEGIN_SRC emacs-lisp
;; Use only authinfo.gpg for password storage
(setq auth-sources '("~/.authinfo.gpg"))
(setq auth-source-gpg-encrypt-to (list user-mail-address))
#+END_SRC

*** Encrypting information
I need a way to store some sensitive information without that being
published, should I decide some day to push this config somewhere.

One solution is to have all these in a separate file, and not publish
that file. I’m also encrypting the file, as I’m sure I *will* publish
it by accident some day.

For settings that are made in elisp, load secrets.el.gpg which will
be encrypted automatically.
#+BEGIN_SRC emacs-lisp
  ;; Use my email-address for encryption
  (setq-default epa-file-encrypt-to user-mail-address)
  ;; Make sure we always use this
  (setq-default epa-file-select-keys nil)
#+END_SRC

Apart from this there is some inline content that is not suitable for
storing in the secrets file. For org-mode for example, there is a way
to encrypt sections separately. See [[Encrypting information in org-mode]]
for the details on the settings for this.

Next to inline content in org that needs encryption, there is also
content that needs encrypting which is more suitable to store in a
separate file for several reasons.
** Global Generic settings
#+BEGIN_SRC emacs-lisp
  ;; disable auto-save files (#foo#)
  (setq
   auto-save-default nil

   ; disable backup files (foo~)
   backup-inhibited t

   ; disable auto-save-list/.saves
   auto-save-list-file-prefix nil

   ; move files to the trash instead of rm
   delete-by-moving-to-trash t

   ; use clipboard
   x-select-enable-clipboard t

   display-warning-minimum-level 'error
   large-file-warning-threshold nil
   tab-width 4
   find-file-use-truenames nil
   find-file-compare-truenames t

   minibuffer-max-depth nil
   minibuffer-confirm-incomplete t
   complex-buffers-menu-p t
   next-line-add-newlines nil
   kill-whole-line t
   truncate-lines t
  )

  (global-visual-line-mode 1)

  ;; Only require to type 'y' or 'n' instead of 'yes' or 'no' when prompted
  (fset 'yes-or-no-p 'y-or-n-p)

  ; Use auto revert mode globally
  ; This is save because emacs tracks if the file is saved in the editting buffer
  ; and if so, it will not revert to the saved file.
  (global-auto-revert-mode t)
  ;; Also for dired
  (setq global-auto-revert-non-file-buffers t)

  ;; Turn on auto-fill minor mode for all text buffers
  (add-hook 'text-mode-hook 'turn-on-auto-fill)

  ;; Should this be here?
  ;; Try to have urls and mailto links clickable everywhere
  (define-global-minor-mode global-goto-address-mode
    goto-address-mode
    (lambda ()
      (goto-address-mode 1)))
  (global-goto-address-mode t)
#+END_SRC
** Internationalisation and multi-language features
If anything multi-language should work, UTF-8 encoding is a must, so
let's make sure we try to use that everywhere
#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
(setq current-language-environment "UTF-8")
#+END_SRC

For conveniently editting accented characters like 'é' and 'è' there
are quite a few options to reach that result. I have dead characters
configured as an option in the operating system, but that is far from
ideal, especially when programming. As I hardly need those characters
outside of emacs, i can leave that option as needed and optimize Emacs
to my needs.

The fallback is C-x 8 C-h which gives specific shortcuts for special
characters which are available. For the exotic characters that will do
just fine. For the more common characters the C-x 8 prefix is to
complex.

After evaluating some systems, the TeX input method suits me the
best. I'd like to enable that globally by default, which needs two
things:
1. enable multi-language editting by default (input-method is only
   active in a multi-language environment)
2. set the default input-method to tex

There is however a problem, the TeX input method assumes the first
character / string produced will always be the choice I need, without
allowing selecting an alternative. This turns out to be due to
=quail-define-package= which determines the way the completions work.
The problem is the =DETERMINISTIC= argument of the function, that is set
to 't'. (8th argument). While I am at it, I also changed the
=FORGET-LAST-SELECTION= (7th argument) to nil, so the last seleciton is
remembered.

For this to work properly we have to define a whole new input-method
based on a copy of latin-ltx.el

#+BEGIN_SRC emacs-lisp
  ;; Register a new input method
  (register-input-method
   "MyTeX" "UTF-8" 'quail-use-package
   "\\" "Personalized TeX input method"
   "~/.emacs.d/mytex-inputmethod")
  ;; Set the default input method to TeX
  (setq default-input-method "MyTeX")
  ;; Enable multi-language mode by default Not sure what to do here: C-\
  ;; toggles the input-method

#+END_SRC
** Package Management
Package handling, do this early so emacs knows where to find things.

I want to manage my packages with el-get. This has grown over time,
because el-get has worked well for me so far. I don’t think I have
used the built-in package management of Emacs 24 much.

The *important* bit here is that this section manages *ALL* my packages,
including the ones gotten from apt-get, git and elpa.
The reason for this is that it provides one neat umbrella (in Emacs)
to manage its packages.

We manage everything with =el-get= so we start by loading that if we
don't have it already.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat emacs-directory "/el-get/el-get"))

  (unless  (require 'el-get nil 'noerror)
    (url-retrieve
     "https://github.com/dimitri/el-get.git/raw/master/el-get-install.el"
     (lambda (s)
       (goto-char (point-max))
       (eval-print-last-sexp))))
#+END_SRC

Now, =el-get= is either require’d, and thus available, or loaded by the
el-get installer, in which case it is also available.

The rest is basically a long list of sources for el-get where to get
the packages from and how to install and update them.
When installing a new package, add a recipe in this list, eval it,
and run =el-get-install= with the package name.

#+BEGIN_SRC emacs-lisp
  ;; Personal or adapted recipes
  (setq el-get-sources
        '(
          ;; Obviously we need el-get itself, so we can run a self-update
          ;; There is a recipe, but we want the master branch of it
          (:name el-get :branch "master")
          ;; Using a different source than the built-in recipe (why was this again?)
          (:name zenburn-emacs :type github :pkgname "bbatsov/zenburn-emacs")
          ;; Version from elpa does not work for me (init problem?)
          (:name cursor-chg :type github :pkgname  "emacsmirror/cursor-chg" :features cursor-chg)
          (:name php-mode-improved)    ; Just to have example for other syntax
          (:name newlua-mode :type github :pkgname "immerrr/lua-mode" :features lua-mode)
          (:name oauth :type github :pkgname "psanford/emacs-oauth")
          (:name expand-region :type github :pkgname "magnars/expand-region.el")
          (:name mark-multiple :type github :pkgname "magnars/mark-multiple.el")
          (:name fixed-point-completion :type github :pkgname "smithzvk/fixed-point-completion")
          (:name xlicense :type github :pkgname "emacsmirror/xlicense")
          (:name autosmiley :type github :pkgname "emacsmirror/autosmiley")
          (:name async :type github :pkgname "jwiegley/emacs-async")
          (:name pcache :type github :pkgname "sigma/pcache")
          (:name logito :type github :pkgname "sigma/logito")
          (:name gh :type github :pkgname "sigma/gh.el" :depends (pcache logito))
          (:name gisthub :type github :pkgname  "defunkt/gist.el" :depends (gh))
          (:name stripe-buffer :type github :pkgname "sabof/stripe-buffer")
          (:name keyfreq :type github :pkgname "dacap/keyfreq")
          (:name git-auto-commit-mode :type github :pkgname "ryuslash/git-auto-commit-mode")
          (:name ujelly-theme :type github :pkgname "marktran/color-theme-ujelly")
          (:name erc-tweet :type github :pkgname "kidd/erc-tweet.el")
          (:name erc-image :type github :pkgname "mrvdb/erc-image.el")
          (:name flycheck :type github :pkgname "lunaryorn/flycheck")
          (:name org-present :type github :pkgname "rlister/org-present")
          (:name popup :type github :pkgname "auto-complete/popup-el")
          (:name auto-complete :type github :pkgname "auto-complete/auto-complete")
          (:name dash :type github :pkgname "magnars/dash.el") ;; Dependency? I dont use this directly
          (:name gitmessenger :type github :pkgname "syohex/emacs-git-messenger")
          (:name metaweblog :type github :pkgname "punchagan/metaweblog.el")
          (:name org-screenshot :type github :pkgname "dfeich/org-screenshot")
          (:name org-agenda-property :type github :pkgname "Bruce-Connor/org-agenda-property")
          (:name pump.io :type github :pkgname "cnngimenez/pumpio-el")
          (:name elfeed :type github :pkgname "skeeto/elfeed")
        )
  )

  (setq mrb/packages
        (append
         ;; list of packages we use from standard recipes
         '(smex ace-jump-mode apache-mode gnuplot-mode sudo-save erc-highlight-nicknames
                edit-server magit markdown-mode rainbow-mode rainbow-delimiters scratch popwin
                highlight-parentheses multiple-cursors wrap-region git-commit-mode cl-lib keywiz
                smart-tab yaml-mode org-jekyll hideshow-org oauth flim)
         ;; the sources we have configured above
         (mapcar 'el-get-as-symbol (mapcar 'el-get-source-name el-get-sources))))

  (el-get 'sync mrb/packages)
#+END_SRC

** Visual
Many settings have to do with how the screen looks and behaves in a
visual way. Thing like colors, highlighting etc. go fall into this
category.

I generally use dark backgrounds, so let's tell Emacs that.
#+BEGIN_SRC emacs-lisp
(setq-default frame-background-mode 'dark)
#+END_SRC

Set the zenburn theme, slightly corrected for a darker
background color. The default one is to light in daylight conditions.
#+BEGIN_SRC emacs-lisp
  ;; FIXME: this should be done in a different way
  (defvar zenburn-bg "#252525")
  (defvar zenburn-bg-1 "#252525")
  (require 'zenburn-theme)
  (load-theme 'zenburn)
#+END_SRC

The zenburn theme does not fit for everything so I have a number of
correction, of which the most important one is loading the ujelly
theme. I do it like this because zenburn is more complete than ujelly
and otherwise I'd have a large set of faces defined in a wrong color.
#+BEGIN_SRC emacs-lisp
  ;; Adjust zenburn with the ujelly theme which makes is a bit more vibrant.
  ;; This is obviously not the way to do this, but it works for me
  ;;(require 'ujelly-theme)
  ;;(load-theme 'ujelly)

  ;; Zenburn underlines date face in org, no go
  (set-face-attribute 'org-date nil :underline nil)


  ;; Adjust the faces for the modeline
  (set-face-attribute 'mode-line nil :foreground "white" :background "grey40" :box nil)
  (set-face-attribute 'mode-line-inactive nil :box nil :underline nil :overline "grey40")

  (set-face-attribute 'isearch nil :background "black" :foreground "tomato")
  (set-face-attribute 'lazy-highlight nil :inherit isearch-lazy-highlight
                      :background "sea green" :foreground "black")

#+END_SRC

I enable hightlighting matching parentheses in many levels
globally. I do not know of a situation where not knowing which
bracket or parenthesis goes with which is not a useful thing.

Define the colors for the parentheses at different levels. One catch
here is that the configuration needs one more color than is actually
used. The last entry here does not get highlighted, so my config is
valid for 5 levels, not 6.
#+BEGIN_SRC emacs-lisp
(setq hl-paren-colors (quote ("firebrick" "lightgreen" "orange" "cyan" "yellow" "blue")))
#+END_SRC

And enable the minor mode globally.
#+BEGIN_SRC emacs-lisp
  (define-globalized-minor-mode global-highlight-parentheses-mode
    highlight-parentheses-mode
    (lambda ()
      (highlight-parentheses-mode t)))
  (global-highlight-parentheses-mode t)

  ;; no splash screen
  (setq inhibit-startup-screen  t)
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)

  ;; check speed consequences of this
  (setq column-number-mode t)

  ;; When I am not typing, the cursor should become more visible, so I
  ;; don't lose it.
  (require 'cursor-chg)                   ; Load this library
  (change-cursor-mode 0)                  ; On for overwrite/read-only/input mode
  (toggle-cursor-type-when-idle 1)        ; On when idle
  (setq curchg-default-cursor-color "LightGreen")
  (setq curchg-default-cursor-type (quote bar\ \.\ 1))

  ;; Default frame properties frame position, color, etc
  (setq default-frame-alist
        '((cursor-type . (bar . 1))
          (cursor-color . "LightGreen")
          (height . 60)
          (width . 100)
  ))

  ;; Parenthesis matching
  (show-paren-mode 1)
  (setq show-paren-style (quote expression))
  (setq show-paren-delay 0)

  ;; As we start emacs in daemon mode, certain (mostly visual) settings
  ;; do not get applied. This is because starting the daemon does not
  ;; open an X connection. This only happens when frames are being
  ;; opened. By adding these settings to the 'server-visit-hook' we can
  ;; still seemingly painless apply these settings.
  (defun run-client-settings()
    (interactive)

    (tool-bar-mode -1)   ;; No tool-bar
    (scroll-bar-mode -1) ;; No scroll-bar
    (menu-bar-mode -1)   ;; No menu-bar
    (tooltip-mode -1)    ;; No tooltips

    ;; When making a selection of in case of highlighting a region
    ;; automatically, keep all font-locking in the region instead of
    ;; just overwriting the whole section. The trick here is to specify
    ;; nil in the foreground attribute
    (defvar mrb-bg-paren-match "gray22")
    (set-face-attribute 'show-paren-match nil
                        :inherit nil :foreground nil
                        :weight 'normal :background mrb-bg-paren-match)

    (defvar mrb-bg-region "gray35")
    ;; Set regions so we keep the normal font locking
    (set-face-attribute 'region nil
                        :inherit nil :foreground nil
                        :weight 'normal :background mrb-bg-region)

    ;; The above did not work for magit, let's try it after loading magit
    (eval-after-load "magit"
      '(set-face-attribute 'magit-item-highlight nil :inherit nil :foreground nil
                           :background mrb-bg-paren-match))
    )

  ;; Defer fontification a little bit, so we could gain a bit in scroll speed
  (setq jit-lock-defer-time 0.02)

  ;; This seems to work if we start up emacs using filename on cli and
  ;; server was not running yet. It does however not work if we just
  ;; startup emacs (through my edit script) without a filename on the cli
  (add-hook 'server-visit-hook 'run-client-settings)
  ;; But we also want to run it, regardless
  (run-client-settings)

  ;; Make colorful balanced parentheses etc. in different modes
  (add-hook 'lisp-mode 'rainbow-delimiters-mode)
#+END_SRC

** Buffers and files
How do I deal with all those buffers?

For starters, make sure that they have unique buffer names so I don't
get confused:
#+BEGIN_SRC emacs-lisp
  ;; nicer buffer names
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; Minibuffer prompt is a prompt, don't enter it as text.
  (setq minibuffer-prompt-properties (quote (read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)))

  ;; Save places in buffers between sessions
  (setq-default save-place t)
  (require 'saveplace)

  (provide 'buffers)
#+END_SRC
** Modes
Customisation setting for specific models
#+BEGIN_SRC emacs-lisp
  ;;
  ;; Extension mappings
  ;;

  ;; First, specify which files to load when functions are called
  (autoload 'markdown-mode "markdown-mode" "Markdown." t)
  (autoload 'gnuplot-mode  "gnuplot"       "GNU-Plot" t)
  (autoload 'php-mode      "php-mode"      "PHP" t)
  (autoload 'css-mode      "css-mode"      "Mode for editing CSS file" t)
  (autoload 'apache-mode   "apache-mode"   "Apache config files" t)

  (add-hook 'javascript-mode-hook 'javascript-custom-setup)
      (defun javascript-custom-setup ()
        (moz-minor-mode 1))

  ;; Second, specify the extension to function mappings
  (add-to-list 'auto-mode-alist '("\\.org\\'"      . org-mode))
  (add-to-list 'auto-mode-alist '("\\.txt\\'"      . org-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.gp\\'"       . gnuplot-mode))
  (add-to-list 'auto-mode-alist '("\\.php\\'"      . php-mode))
  (add-to-list 'auto-mode-alist '("\\.css$"        . css-mode))
  (add-to-list 'auto-mode-alist '("\\.js$"         . javascript-mode))
  (add-to-list 'auto-mode-alist '("\\.htaccess"    . apache-mode))
  (add-to-list 'auto-mode-alist '("\\.patch"       . diff-mode))
  (add-to-list 'auto-mode-alist '("\\.zsh"         . sh-mode))

  ;; Open scratch buffer by default in the mode we are in at the moment
  ;; with C-u prefix a mode will be asked to use
  (require 'scratch)

  ;; Turn on eldoc for modes which support it
  (dolist
      (the_mode
      (list 'emacs-lisp-mode-hook 'lisp-interaction-mode-hook 'ielm-mode-hook 'python-mode))
    (add-hook the_mode 'turn-on-eldoc-mode))

  ;; Autofill should be off for a couple of modes
  (dolist
      (the_mode
       (list 'nxml-mode))
    (add-hook the_mode 'turn-off-auto-fill))

  ;; Truncate lines in some modes
  (dolist
      (the_mode
       (list 'python-mode))
    (add-hook the_mode (toggle-truncate-lines 1)))
#+END_SRC
*** Org-mode
Orgmode configuraton is probably the largest part of my Emacs
configuration, because most of the time I spent in Emacs, when not
coding, is spent in org-mode.
**** Initialisation of Orgmode
Basically where to find stuff and what to load.

We do not have to load the main orgmode location, because we already
did that on the main initialisation to get org-babel started.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/dev/emacs/packages/org-mode/contrib/lisp/")
  (add-to-list 'load-path "~/dev/emacs/packages/org-mode/contrib/babel/langs/")

  ;; Also make sure we never load org from internal, this can happen
  ;; when functions were defined in the included org version and not
  ;; anymore in newer versions. We want an error, not a silent load of
  ;; the older function.

  (delete  "/usr/local/share/emacs/24.3/lisp/org" load-path)
  ;; CHECKME: is this still the proper installation method, it has changed a lot lately
  (require 'org)                   ;; This is required, see installation docs
  (require 'org-clock)             ;; Should not be needed, but otherwise links don't work
  (require 'org-mouse)             ;; Enable menu on right mouse button and other mouse functions
  ;; FIXME: for v8 this isn't working?
  ;;(require 'org-special-blocks)  ;; Generalizes the #+begin_foo and #+end_foo blocks,
                                   ;; useful on latex (export)
  (require 'org-datetree)          ;; Allows for archiving and refiling in a date organised tree
  (require 'org-mobile)            ;; Only org-mobile-push and pull get autoloaded and we need
                                   ;; the file list before that.
#+END_SRC

Most of work originates in capturing some task item in orgmode. Set
up the location and files for that.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/.outlet/")
(setq org-metadir (concat org-directory "_orgmeta/"))
(setq org-archive-location (concat org-metadir "archive.org::date-tree"))
(setq org-default-notes-file (concat org-directory "GTD.org"))
(setq diary-file (concat org-metadir "DIARY"))
#+END_SRC

Finally, run some things when entering orgmode.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

**** Capturing information
I guess 90% of the information I keep in the main orgmode files
starts life originally as a captured item. I use it for:

1. TODO items;
2. BUY items;
3. Journaling entries;
4. Statusnet Updates;

Make sure org-capture is available:
#+BEGIN_SRC emacs-lisp
(require 'org-capture)
#+END_SRC

Here are the templates used for them.
#+BEGIN_SRC emacs-lisp
  (setq
   org-capture-templates
   (quote (
           ("b" "Buy"
            entry (id "new-todo-receiver") "* BUY %? :buy:\n" :prepend t)
           ("t" "Todo"
            entry (id "new-todo-receiver") "* TODO %?" :prepend t)
           ("j" "Journal"
            entry (file+datetree (concat org-directory "journal.org"))
            "* ___________________________________________________________ *%U* ___\n\n%?\n")
           )
          )
   )
#+END_SRC

The concept I use for capturing is that a window is opened in the
center of the screen, on top of all windows, on all workspaces, so it
shows up whenever I press the shortcut key for it. The exception to
this rule is journaling entries, which go into a regular Emacs frame.

So, the first thing I need is a way to create a capturing frame and
proper arrangement for finalising the capturing; the frame should be
deleted. The frame should also be deleted if the capture is destroyed
for some reason. The two =defadvice= snippets take care of this. Also,
by default org-capture splits the screen; we do not need that as we
have a dedicated frame for it, so on entering capture mode we just
delete the other windows which may be in the frame.
#+BEGIN_SRC emacs-lisp
  (defun make-capture-frame ()
    "Create a new frame for org-capture to use."
    (select-frame (make-frame '((name . "capture")
                                (width . 115) (height . 15)
                                (menu-bar-lines . 0) (tool-bar-lines . 0))))
    )

  (defadvice org-capture-finalize (after delete-capture-frame activate)
    "Advise org-capture-finalize to close the frame if it is the capture frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defadvice org-capture-destroy (after delete-capture-frame activate)
    "Advise org-capture-destroy to close the frame if it is the capture frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (add-hook 'org-capture-mode-hook 'delete-other-windows)
#+END_SRC

Define functions for each piece of information captured, so they can
be easily bound to keys.
#+BEGIN_SRC emacs-lisp
  (defun capture-todo ()
    "Capture a TODO item"
    (interactive)
    (make-capture-frame)
    (org-capture nil "t")
    )

  (defun capture-buy ()
    "Capture a BUY item"
    (interactive)
    (make-capture-frame)
    (org-capture nil "b")
    )
  (defun make-journal-entry ()
    "Create a journal entry"
    (interactive)
    (org-capture nil "j")
  )

#+END_SRC

By default C-c C-c ends the capture, but is normally the shortcut to
enter tags, so I define a shortcut to define tags while capturing.

#+BEGIN_SRC emacs-lisp
  (defun mrb/add-tags-in-capture()
    (interactive)
    "Insert tags in a capture window without losing the point"
    (save-excursion
      (org-back-to-heading)
      (org-set-tags)))

  (define-key org-capture-mode-map "\C-c\C-t" 'mrb/add-tags-in-capture)
#+END_SRC

Capturing dents for status updates in statusnet are done the
same. Their config is in the section [[Statusnet]]

Capturing of screenshots is provided by the org-screenshot library.
#+BEGIN_SRC emacs-lisp
  (require 'org-screenshot)

  (defun capture-screenshot()
    "Capture a screenshot"
    (interactive)
    ;; Always create the standard attach dir if there is none
    (org-attach-dir t)

    ;; Don't hide the emacs frame, it's silly
    (org-screenshot t ""))
#+END_SRC

**** Workflow
Orgmode used a couple of thing which enable you to steer the workflow
for items. Item states are the most prominent ones. Org-mode uses
keyword definitions to denote states on items. I keep an [[file:org-config.org][Orgmode
configuration file]] (=org-config.org)= file which contains the
description of the workflow in a formate suitable to include directly
into orgmode files. The configuration of emacs itself is limited to
dressing up this configuration with things less suitable to go into
that config file. The configuration here and the org config file
should be kept in sync.

Adapt the colors of the states I use a bit:
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keyword-faces '(
    ("DONE"   .    (:foreground "#afd8af"     :weight bold))
    ("WAITING"   . (:foreground "dark salmon" :weight bold))
    ("CANCELLED" . (:foreground "dim gray"    :weight bold))
    ("BUY      " . (:foreground "goldenrod"   :weight bold))
  ))
#+END_SRC

Make sure we keep a clean tag slate when changing tag state. This
means that when I move to an active state, remove inactive tags; if
something is DONE, remove tags from it and automatically adding a
'buy' tag when a BUY item is created.
Note: capturing does not honour this, i.e. when creating a new item.
#+BEGIN_SRC emacs-lisp
  (setq org-todo-state-tags-triggers
        (quote (
                ('todo ("inactive"))          ; remove inactive tags if moved to any active state
                ('done ("inactive") ("fork")) ; remove tags from any inactive state
                ("BUY"  ("buy" . t)))))       ; add buy tag when this is a buying action
#+END_SRC

To keep the TODO list clean we immediately archive the completed
entry in the archive. The archiving only occurs when an item enters
the 'DONE' state and the item is not marked as a habit.

I'm not sure if this works out in practice
without having a confirmation (because we archive the whole subtree),
so for now, I'm building in the confirmation.
#+BEGIN_SRC emacs-lisp
  (require 'org-habit)

  ;; I need a modified version of org-is-habit, which takes inheritance
  ;; in to account
  (defun mrb/org-is-habit-recursive-p (&optional pom)
    "Is the task at POM or point a habit, taking property
  inheritance into account?"
    (equalp "habit" (org-entry-get (or pom (point)) "STYLE" t)))

  (defun mrb/archive-done-item()
    ;; Determine if the item went to the DONE/CANCELLED state
    ;; if so, ask to archive it, but skip habits which have
    ;; their own logic.
    (when (not (mrb/org-is-habit-recursive-p))
      ;; No habit, so we have a candidate
      (progn
       ;; Try to use a dialog box to ask for confirmation
       (setq last-nonmenu-event nil)

       ;; When a note is going to be added, postpone that Otherwise just
       ;; run the archiving question
       ;; FIXME: org-add-note runs through post-command-hook,
       ;;        which is kinda weird, how to i get it to run
       ;;        before the archiving question?
       (when (equal org-state "DONE")
         (org-archive-subtree-default-with-confirmation)))))


  ;; Run archive for the item that changed state
  (add-hook 'org-after-todo-state-change-hook
            'mrb/archive-done-item t)

#+END_SRC
**** Registering creation time of todo items
Over time it gets a bit messy in my orgmode files. I can not remember
when something was created and thus, by judging the time I didn't do
anything with the item, decide if it is still important or not.

So, to help with that I created a little glue to make sure each
actionable item gets a =CREATED= property with the date in it on which
that item was created. I use the contributed =org-expiry= for that and
adjust it a bit.

I want the property to be name 'CREATED' (I don't remeber what the
org-expirty default name is, but it is different) and the timestamps
inserted must not be active, otherwise they'll appear all over the
place in the agenda.
#+BEGIN_SRC emacs-lisp
  (require 'org-expiry)

  (setq org-expiry-created-property-name "CREATED")
  (setq org-expiry-inactive-timestamps   t)
#+END_SRC

So, to create the timestamp I need a little helper function which
actually inserts it, using org-expiry. There is some additional
cursor munging to make sure it is used comfortably during editing.
#+BEGIN_SRC emacs-lisp
  (defun mrb/insert-created-timestamp()
    "Insert a CREATED property using org-expiry.el for TODO entries"
    (org-expiry-insert-created)
    (org-back-to-heading)
    (org-end-of-line)
    (insert " ")
  )
#+END_SRC

Now that function is used to insert the proprty when:
1. creating a TODO heading, using an advice to =insert-todo-heading=
2. capturing an item, but only when it is a TODO item (i.e. has a
   defined keyword)
#+BEGIN_SRC emacs-lisp
  (defadvice org-insert-todo-heading (after mrb/created-timestamp-advice activate)
    "Insert a CREATED property using org-expiry.el for TODO entries"
    (mrb/insert-created-timestamp)
  )
  (ad-activate 'org-insert-todo-heading)

  (require 'org-capture)
  (defadvice org-capture (after mrb/created-timestamp-advice activate)
    "Insert a CREATED property using org-expiry.el for TODO entries"
    (when (member (org-get-todo-state) org-todo-keywords-1)
      (mrb/insert-created-timestamp)))
  (ad-activate 'org-capture)
#+END_SRC

**** Visual settings
Having an attractive screen to look at becomes more important if you
use the system all day long. /Attractive/ is rather subjective
here. For me it mainly consists of functional things. Anyways, this
section groups settings for the visual characteristics of orgmode.

I want to hide the leading stars in the outliner, and do it *exactly*
in the background color. This is redundant actually in my case, as it
is also specified in the org config file that I include. Or rather,
it is redundant there, because I want it always to be the case.
#+BEGIN_SRC emacs-lisp
(setq org-hide-leading-stars t)
#+END_SRC

For the collapsed items in the outline orgmode uses the variable
=org-ellipsis= to determine what character-sequence should be used to
show that the item can be expanded. The variable can contain a
string, which will then be used instead of the standard 3 dots, or a
face which will then be used to render the standard 3 dots.
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "...")
#+END_SRC

There are a couple of ways within org to emphasize text inline
for *bold*, /italics/, underlined etc. These are set in the text by
enclosing regions with delimiters. I do not want to see these
delimiters, but rather render the text.
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

A similar thing can be done with pretty entity characters (like '\delta'
for example). These characters can be added to the text by adding a
'\' before a symbol name ('delta' in the example).  I make an
exception for the sub- and superscript characters. This happens a lot
in variable names etc. and I a big annoyance if those get rendered to
subscript all the time.
#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities 1)
(setq org-pretty-entities-include-sub-superscripts nil)
#+END_SRC

For most of the source blocks I want Emacs to render those blocks in
their native mode. This had a serious performance problem in the
past, but I think it has been solved recently.
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

A couple of settings to steer the column in which the tags and habits
appear in the frame:
#+BEGIN_SRC emacs-lisp
(setq
   org-tags-column -110
   org-agenda-tags-column -110
   org-habit-graph-column 100
)
#+END_SRC

The item lists can be made a whole lot more attractive by attaching
some icons based on the category an items belongs to. The category
assignment itself is done by setting the =CATEGORY= property explicitly
on the item or on the file.
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-category-icon-alist
        '(
          ("Afspraak"      "~/.outlet/images/stock_new-meeting.png" nil nil :ascent center)
          ("Blogging"      "~/.outlet/images/edit.png" nil nil :ascent center)
          ("Cobra"         "~/.outlet/images/car.png" nil nil :ascent center)
          ("DVD"           "~/.outlet/images/media-cdrom.png" nil nil :ascent center)
          ("Emacs"         "~/.outlet/images/emacs.png" nil nil :ascent center)
          ("Finance"       "~/.outlet/images/finance.png" nil nil :ascent center)
          ("Habitat"       "~/.outlet/images/house.png" nil nil :ascent center)
          ("Habit"         "~/.outlet/images/stock_task-recurring.png" nil nil :ascent center)
          ("Hobbies"       "~/.outlet/images/hobbies.png" nil nil :ascent center)
          ("Partners"      "~/.outlet/images/partners.png" nil nil :ascent center)
          ("Personal"      "~/.outlet/images/personal.png" nil nil :ascent center)
          ("Task"          "~/.outlet/images/stock_todo.png" nil nil :ascent center)
          ("Org"           "~/.outlet/images/org-mode-unicorn.png" nil nil :ascent center)
          ("Statusnet"     "~/.outlet/images/statusnet.png" nil nil :ascent center)
          ("Systeem"       "~/.outlet/images/systeembeheer.png" nil nil :ascent center)
          ("Wordpress"     "~/.outlet/images/wordpress.png" nil nil :ascent center)
  ))
#+END_SRC

Showing items in the agenda views reacts to a number of settings. In
my setup I want blocked tasks hidden, that is the reason for
blocking. Hide tasks which are DONE already and a deadline is coming
up, no use showing those; the same goes for tasks which are DONE and
are scheduled. In short, anything that does not need my attention
needs to be hidden.
#+BEGIN_SRC emacs-lisp
  (setq
      org-agenda-dim-blocked-tasks t
      org-agenda-skip-deadline-if-done t
      org-agenda-skip-scheduled-if-done t
      org-agenda-skip-archived-trees nil
  )
#+END_SRC

**** Agenda customization
#+BEGIN_SRC emacs-lisp
  (require 'keywiz)

  ;; Helper function to build a set of functions and their
  (defun mrb/load-keybindings ()
    "Since we don't want to have to pass through a keywiz game each time..."
    (setq keywiz-cached-commands nil)
    (do-all-symbols (sym)
      (when (and (commandp sym)
                 (not (memq sym '(self-insert-command
                                  digit-argument undefined))))
        (let ((keys (apply 'nconc (mapcar
                                   (lambda (key)
                                     (when (keywiz-key-press-event-p key)
                                       (list key)))
                                   (where-is-internal sym)))))
          ;;  Politically incorrect, but clearer version of the above:
          ;;    (let ((keys (delete-if-not 'keywiz-key-press-event-p
          ;;                               (where-is-internal sym))))
          (and keys
               (push (list sym keys) keywiz-cached-commands))))))

  ;; Load em up
  (mrb/load-keybindings)

  ;; Might be good to use this in org-agenda...
  (defun mrb/random-keybinding ()
    "Describe a random keybinding."
    (interactive)
    (let* ((command (keywiz-random keywiz-cached-commands))
           (doc (and command (documentation (first command)))))
        (if command
            (concat (symbol-name (first command)) " "
                    "(" (mapconcat 'key-description (cadr command) ", ") ")"
                    (if doc
                        (concat ": " (substring doc 0 (string-match "\n" doc)))
                      ""))
          "")))


  ;; Call this function in a multipart agenda command.
  (defun mrb/org-agenda-show-tip (arg)
    (interactive)
    (let ((inhibit-read-only t))
      (insert "A random keybinding for inspiration:\n  ")
      (insert (mrb/random-keybinding) "\n")))

  ;; Show properties in agenda view
  (require 'org-agenda-property)
  (setq org-agenda-property-list '("LOCATION" "Responsible"))
#+END_SRC
**** Babel / Literate programming
#+BEGIN_SRC emacs-lisp
  (setq
     org-babel-interpreters (quote ("emacs-lisp" "python" "ditaa" "sql" "sh" "R"))
  )
  ;; Activate Babel languages
  (require 'ob-gnuplot)
  ;;(require 'ob-mathomatic)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t) (ditaa . t) (sql . t) (sh . t) (emacs-lisp t) (lisp t)
     (css t) (awk t) (js t) (lisp t) (org t) (plantuml t) (gnuplot . t)))
#+END_SRC

**** Refiling
A big part of organizing information and task is shuffling things
around. The 'thing' to throw around is a heading and 'refiling' is
the term org-mode uses for throwing.

When filing, or capturing we want the items at the bottom of what we
are filing it into. The main reason for this is that a large part of
the sections that contain items are ordered. Should we file the item
at the top, in many cases that would mean it is the most imminent
thing to do, which is not the case.

#+BEGIN_SRC emacs-lisp
(setq
   org-reverse-note-order nil    ; File at the bottom of an entry
   org-refile-allow-creating-parent-nodes (quote confirm)
   org-refile-targets (quote ((org-agenda-files :maxlevel . 10 )))
   org-refile-use-outline-path 'file
)
#+END_SRC
**** Exporting to other formats
Orgmode can export to a variety of formats, I mainly use LaTeX (PDF)
and HTML as destination format

#+BEGIN_SRC emacs-lisp
  (setq
   org-export-latex-hyperref-format "\\ref{%s}:{%s}"
   ;; old system
   org-export-latex-title-command " "
   ;; new system > 8.0
   org-latex-title-command " "

   org-export-docbook-xsl-fo-proc-command "fop %i %o"
   org-export-docbook-xslt-proc-command "xsltproc --output %o %s %i"
   org-export-htmlize-output-type (quote css)
   org-export-htmlized-org-css-url "orgmode.css"
   org-latex-pdf-process
   (quote
    ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
   org-latex-to-pdf-process
   (quote
    ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

   org-export-copy-to-kill-ring (quote if-interactive)
   org-export-docbook-xsl-fo-proc-command "fop %i %o"
   org-export-docbook-xslt-proc-command "xsltproc --output %o %s %i"
   org-export-htmlize-output-type (quote css)
   org-export-htmlized-org-css-url "orgmode.css"
   org-export-latex-classes
   (quote (
           ("article" "\\documentclass[11pt,a4paper,twoside]{article}"
            ("\\section{%s}" . "\\section*{%s}")
            ("\\subsection{%s}" . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}" . "\\paragraph*{%s}")
            ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
           ("report" "\\documentclass[11pt]{report}"
            ("\\part{%s}" . "\\part*{%s}")
            ("\\chapter{%s}" . "\\chapter*{%s}")
            ("\\section{%s}" . "\\section*{%s}")
            ("\\subsection{%s}" . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
           ("book" "\\documentclass[11pt]{book}"
            ("\\part{%s}" . "\\part*{%s}")
            ("\\chapter{%s}" . "\\chapter*{%s}")
            ("\\section{%s}" . "\\section*{%s}")
            ("\\subsection{%s}" . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
           ("beamer" "\\documentclass{beamer}" org-beamer-sectioning)))
   org-export-latex-hyperref-format "\\ref{%s}:{%s}"
   org-latex-title-command " "
   org-export-latex-title-command " "
   org-export-with-tags nil
   org-export-with-todo-keywords nil

  )

#+END_SRC
#+BEGIN_SRC emacs-lisp
  ; Exporting and Publishing related settings

  ; Apart from the normal export menu, I need something that exports
  ; just the body, so the resulting html is suitable to be used inside a
  ; blogging system like wordpress for example

  ; This puts the body inside a buffer called  blog-entry
  (defun org-export-body-as-html ()
    (interactive)
    (org-export-as-html 3 nil nil "blog-entry" t))

  ; Make sure we export in css mode, meaning no inline css crap
  (setq org-export-htmlize-output-type 'css)
  (define-key org-mode-map "\C-c\C-e" 'org-export-body-as-html)

  (defun org-export-body-as-html-batch ()
    "Call `org-export-as-html', may be used in batch processing as
  emacs   --batch
          --load=$HOME/lib/emacs/org.el
          --eval \"(setq org-export-headline-levels 2)\"
          --visit=MyFile --funcall org-export-body as-html-batch"
    (interactive)
    (org-export-as-html 3 nil nil nil t))
#+END_SRC
**** Blogging with org-mode
Having most of my writings in org-mode it makes sense to add just a
little bit more to be able to push that content to my blogging
platform; wordpress. Fortunately, there's some elisp for that in the
form of org2blog, which publishes orgmode files as wordpress articles
or pages.
For

***** Org2Blog configuration for Wordpress

I use my own repositories mostly
#+BEGIN_SRC emacs-lisp
  ; Directly tie into the GIT org2blog repository
  (add-to-list 'load-path "~/dev/emacs/packages/org2blog/")
  (add-to-list 'load-path "~/dev/emacs/packages/xml-rpc-el/")
  (require 'org2blog-autoloads)
#+END_SRC

The configuration of org2blog is a matter of setting some
variables. First let get some of the basics out of the way.
#+BEGIN_SRC elisp
  (setq
   org2blog/wp-server-weblog-id ""
   org2blog/wp-default-title "<Untitled>"
   org2blog/wp-default-categories ""
   org2blog/wp-confirm-post t)
#+END_SRC

Each blog-entry has it's own file, but is really nothing different
from a normal org-mode file. To be able to have wordpress and orgmode
work together, org2blog could insert some properties into the file,
but I choose to have these in a so called /tracking-file/ which is a
convenient outline of all blog entries. Bij making the header a link
to the file, it makes a convenient system.

#+BEGIN_SRC emacs-lisp
  (setq
   org2blog/wp-track-posts (list "~/dat/blogs/blogs.org" "To be filed properly")
  )
#+END_SRC

This leaves use with the blogs to configure; the name, url and
username are probably the required entries for each blog. I added the
tracker file, which is the same as the global value. Authentication
to the blogs is done interactively by default.
#+BEGIN_SRC emacs-lisp
  (setq org2blog/wp-blog-alist
        '(("cobra"
           :url "http://cobra.mrblog.nl/xmlrpc.php"
           :username "mrb"
           :track-posts ("~/dat/blogs/blogs.org" "cobra.mrblog.nl")
           )
          ("hsd"
           :url "http://test.hsdev.com/xmlrpc.php"
           :username "mrb"
           :track-posts ("~/dat/blogs/blogs.org" "hsdev.com")
           )))

#+END_SRC
***** Using org-jekyll for Jekyll based sites
Using jekyll and orgmode together is a bit more low level, because
jekyll as such is not a blogging solution, it can just parse files
from one format to html. What org-jekyll does is have orgmode
prepare the proper stuff for jekyl so it can be processed.

So, we need the orgmode publishing part and the org-jekyll package:
#+BEGIN_SRC emacs-lisp
  (require 'ox-publish)
  (require 'ox-html)
  (require 'org-jekyll)
#+END_SRC

As there are quite a few different setups possible, it's probably
smart to write a few paragraphs on how to set things up.

As usual, I want it to be as simple as possible at first. One thing
that is sort of fixed is the directory structure that jekyll expects
and I that as a starting point.  Typically there is a =_posts=
subdirectory there which will hold the html files that jekyll will
need to put into the site.

Typically in org-mode, after writing a subtree, which is one blog post
in this case, a call to =org-jekyll-export-current-entry= is
called. This will try to deduce which project org-mode must use to
publish the entry with based on the filename, i.e. is the file in or
below the ':base-directory' of one the publishing projects and has the
proper extension and so on.

Once the publishing project has been established, org-jekyll will then
take the heading of the subtree and use that as the title of the
posting. Some of the properties defined in the subtree will be
converted to the yaml-header that jekyll expects to be present.

Using the export framework of orgmode the entry is then exported to
html and placed into the destination directory for the project,
typically the "_posts" directory of the base jekyll folder.

After that, jekyll can do its thing and have the site published.

Org-jekyl has a couple of special extra features:

- Categories
  If the subtree defines a category property, the post will be placed
  in subfolder wiht the name of that category. Within that
  subdirectory, the converted contents will be placed in a ="_posts"=
  directory. This construct allows for multisites/multicategories.
- Localization
  If a :lang: property is defined it will be used to look for a file
  called =[lang].yml= which will be included in the frontmatter of the
  post. Similarly as with categories, posts end up in =[lang]/_posts=
- when publishing multiple entries at once, for example by using
  =org-jekyll-export-blog=, org-jekyll will only consider subtree which
  have a tag =blog= or =BLOG=


#+BEGIN_SRC emacs-lisp
  ;; I dont use categories in my blog, but i do use multiple blogs
  ;; Define the property to specify that to be "blog"
  (setq org-jekyll-category "blog")

  (setq org-publish-project-alist '(
    ("mrblog-org"
            ;; Path to your org files.
            :base-directory "~/dat/"
            :base-extension "org"

            ;; Path to your Jekyll project.
            :publishing-directory "~/dat/blogs/mrblog/"
            :recursive t
            :publishing-function org-html-publish-to-html
            :headline-levels 4
            :html-extension "html"
            :body-only t ;; Only export section between <body> </body>
      )


      ("mrblog-files"
            :base-directory "~/dat/"
            :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|php"
            :publishing-directory "~/dat/blogs/mrblog/files/"
            :recursive t
            :publishing-function org-publish-attachment)

      ("mrblog" :components ("mrblog-org" "mrblog-files"))

  ))
#+END_SRC
**** Old configuration
Below is what was contained in the old configuration. I will slowly
migrate this into more literal sections

#+BEGIN_SRC emacs-lisp
  (setq
   org-use-fast-todo-selection t

   ; We support task dependencies
   org-enforce-todo-dependencies t
   ; but relax checkbox constraints
   org-enforce-todo-checkbox-dependencies nil

   ; We dont do priorities
   org-enable-priority-commands nil

   ; Agenda settings
   org-agenda-include-diary t
   org-agenda-start-with-log-mode t
   org-agenda-todo-ignore-scheduled "future"

   ; Habits
   org-habit-show-habits-only-for-today nil

   ; Pressing enter on a link should activate it
   org-return-follows-link t
   org-support-shift-select (quote always)

   org-agenda-log-mode-items (quote (closed clock state))
   org-agenda-skip-deadline-prewarning-if-scheduled t
   org-blank-before-new-entry (quote ((heading) (plain-list-item)))
   org-export-htmlize-output-type (quote css)
   org-fast-tag-selection-single-key (quote expert)
   org-file-apps
   (quote
    ((auto-mode . emacs)
    ("\\.dia\\'" . "dia %s")
    ("\\.mm\\'" . default)
    ("\\.pdf\\'" . default)))
   org-fontify-done-headline t
   org-goto-interface (quote outline-path-completion)
   ;; non nil is just direct children, what an ODD name!!!!
   org-hierarchical-todo-statistics nil
   org-provide-todo-statistics t
   org-log-into-drawer t
   org-log-redeadline (quote note)
   org-log-reschedule (quote time)
   org-modules (quote
                (org-info org-jsinfo org-habit
                          org-inlinetask org-irc
                          org-toc org-mac-iCal org-mouse))
   org-remember-default-headline ""
   org-special-ctrl-a/e t
   org-stuck-projects (quote ("-inactive/TODO" ("TODO" "WAITING") nil ""))
   org-track-ordered-property-with-tag nil
  )

  ;; Bit of a leftover from reorganising bits, do this later
  (add-to-list 'org-tags-exclude-from-inheritance (quote "fix"))
  (add-to-list 'org-tags-exclude-from-inheritance (quote "sell"))
  (add-to-list 'org-tags-exclude-from-inheritance (quote "build"))


  ; Keybindings which only make sense when having an orgmode file
  (define-key org-mode-map "\C-ct" 'org-set-tags)

  ;; After 7.9.4(?) the export menu is called by dispatch
  (if
      (version< "7.9.4" (org-version))
      (define-key org-mode-map "\C-ce" 'org-export-dispatch)
    (define-key org-mode-map "\C-ce" 'org-export)
    )

  (define-key org-mode-map [(super .)] 'org-todo)
  (defun force-org-todo()
    (interactive)
    (let ((current-prefix-arg '(64)))  ;; Triple C-u (4^3)
      (call-interactively 'org-todo))
  )
  (defun force-org-agenda-todo()
    (interactive)
    (let ((current-prefix-arg '(64)))  ;; Triple C-u (4^3)
      (call-interactively 'org-agenda-todo))
  )
  (define-key org-mode-map [(control super .)] 'force-org-todo)
  (define-key org-agenda-mode-map [(control super .)] 'force-org-agenda-todo)

  (define-key org-agenda-mode-map [(super .)] 'org-agenda-todo)
  ; Map \cmd{}t to schedule in both task and agenda-view
  (define-key org-mode-map [(super t)] 'org-schedule)
  (define-key org-agenda-mode-map [(super t)] 'org-agenda-schedule)
  (define-key org-mode-map [(meta p)] 'org-set-property)
  (define-key org-agenda-mode-map [(meta p)] 'org-set-property)
  (define-key org-mode-map [(control super s)] 'org-save-all-org-buffers)

  ; Dynamic behaviour
  (defun gtd()
    "Start my GTD system"
    (interactive)
    (find-file org-default-notes-file)
  )


  (defun mrb/is-project-p ()
    "This function returns true if the entry is considered a project.
     A project is defined to be:
     - having a TODO keyword itself (why was this again?);
     - having at least one todo entry, regardless of their state."
    (let ((has-todokeyword)
          (has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      ;; both subtasks and a keyword on the container need to be present.
      (and is-a-task has-subtask)
      )
    )

  ; FIXME: testing for tag presence should be easier than a re-search forward
  ; FIXME: are we not searching for all 'incomplete' type keywords here?,
  ;        there must be an org function for that
  (defun mrb/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (has-next (save-excursion
                       (forward-line 1)
                       (and (< (point) subtree-end)
                            (re-search-forward "^*+ \\(TODO\\|BUY\\|WAITING\\)" subtree-end t)))))
      (if (and (mrb/is-project-p) (not has-next))
          nil ; a stuck project, has subtasks but no next task
        subtree-end)))

  (defun mrb/skip-non-projects ()
    "Skip trees that are not projects"
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (mrb/is-project-p)
          nil
        subtree-end)))

  (defun mrb/skip-projects ()
    "Skip trees that are projects"
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (mrb/is-project-p)
          subtree-end
        nil)))

  (defun mrb/save-containing-org-file()
    ;; FIXME: this is a bit over the top, especially as I am auto
    ;; commiting to a git repository.
    (org-save-all-org-buffers)
  )
  (add-hook 'org-after-todo-state-change-hook 'mrb/save-containing-org-file)

  ; When in agenda mode, show the line we're working on.
  (add-hook 'org-agenda-mode-hook '(lambda () (hl-line-mode 1)))

    ; When a tag change adds the waiting tag, make sure it gets scheduled
  ; 1 week from now if it is not already.
    (defun autoschedule-waiting()
    ; variable 'tags' contains the values of the tag-string
    ; If tags has the tag :waiting:, schedule this
    ;(if includes tags "waiting")
    (message "Running my own hook")
    ;(message tags)
    (org-schedule nil (org-timestring-to-seconds "+1w"))
  )
  ; Activate it
  ;(add-hook 'org-after-tags-change-hook 'autoschedule-waiting)



  ; Remove empty property drawers
  (defun mrb/org-remove-empty-propert-drawers ()
    "*Remove all empty property drawers in current file."
    (interactive)
    (unless (eq major-mode 'org-mode)
      (error "You need to turn on Org mode for this function."))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward ":PROPERTIES:" nil t)
        (save-excursion
          (org-remove-empty-drawer-at "PROPERTIES" (match-beginning 0))))))

  (defun mrb/org-remove-redundant-tags ()
    "Remove redundant tags of headlines in current buffer.

  A tag is considered redundant if it is local to a headline and
  inherited by a parent headline."
    (interactive)
    (when (eq major-mode 'org-mode)
      (save-excursion
        (org-map-entries
         '(lambda ()
            (let ((alltags (split-string (or (org-entry-get (point) "ALLTAGS") "") ":"))
                  local inherited tag)
              (dolist (tag alltags)
                (if (get-text-property 0 'inherited tag)
                    (push tag inherited) (push tag local)))
              (dolist (tag local)
                (if (member tag inherited) (org-toggle-tag tag 'off)))))
         t nil))))


  (defvar org-agenda-group-by-property nil
    "Set this in org-mode agenda views to group tasks by property")

  (defun org-group-bucket-items (prop items)
    (let ((buckets ()))
      (dolist (item items)
        (let* ((marker (get-text-property 0 'org-marker item))
               (pvalue (org-entry-get marker prop t))
               (cell (assoc pvalue buckets)))
          (if cell
              (setcdr cell (cons item (rest cell)))
            (setq buckets (cons (cons pvalue (list item))
                                buckets)))))
      (setq buckets (mapcar (lambda (bucket)
                              (cons (first bucket)
                                    (reverse (rest bucket))))
                            buckets))
      (sort buckets (lambda (i1 i2)
                      (string< (first i1) (first i2))))))

  (defadvice org-agenda-finalize-entries (around org-group-agenda-finalize
                                                 (list &optional nosort))
    "Prepare bucketed agenda entry lists"
    (if org-agenda-group-by-property
        ;; bucketed, handle appropriately
        (let ((text ""))
          (dolist (bucket (org-group-bucket-items
                           org-agenda-group-by-property
                           list))
            (let ((header (concat "Property "
                                  org-agenda-group-by-property
                                  " is "
                                  (or (first bucket) "<nil>") ":\n")))
              (add-text-properties 0 (1- (length header))
                                   (list 'face 'org-agenda-structure)
                                   header)
              (setq text
                    (concat text header
                            ;; recursively process
                            (let ((org-agenda-group-by-property nil))
                              (org-agenda-finalize-entries
                               (rest bucket) nosort))
                            "\n\n"))))
          (setq ad-return-value text))
      ad-do-it))
  (ad-activate 'org-agenda-finalize-entries)


  ;; Shorten url at point
  ;; This is a stripped down version of the code in identica-mode
  (defun mrb/ur1ca-get (api longurl)
    "Shortens url through ur1.ca free service 'as in freedom'"
    (let* ((url-request-method "POST")
          (url-request-extra-headers
           '(("Content-Type" . "application/x-www-form-urlencoded")))
          (url-request-data (concat "longurl=" (url-hexify-string longurl)))
          (buffer (url-retrieve-synchronously api)))
      (with-current-buffer buffer
        (goto-char (point-min))
        (prog1
            (if (search-forward-regexp "Your .* is: .*>\\(http://ur1.ca/[0-9A-Za-z].*\\)</a>" nil t)
                (match-string-no-properties 1)
              (error "URL shortening service failed: %s" longurl))
        (kill-buffer buffer)))))

  (defun mrb/shortenurl-replace-at-point ()
    "Replace the url at point with a tiny version."
    (interactive)
    (let ((url-bounds (bounds-of-thing-at-point 'url)))
      (when url-bounds
        (let ((url (mrb/ur1ca-get "http://ur1.ca" (thing-at-point 'url))))
          (when url
            (save-restriction
              (narrow-to-region (first url-bounds) (rest url-bounds))
              (delete-region (point-min) (point-max))
              (insert url)))))))


  (defvar mrb/org-my-archive-expiry-days 365
    "The number of days after which a completed task should be auto-archived.
  This can be 0 for immediate, or a floating point value.")

  (defun mrb/org-my-archive-done-tasks ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (let ((done-regexp
             (concat "\\* \\(" (regexp-opt org-done-keywords) "\\) "))
            (state-regexp
             (concat "- State \"\\(" (regexp-opt org-done-keywords)
                     "\\)\"\\s-*\\[\\([^]\n]+\\)\\]")))
        (while (re-search-forward done-regexp nil t)
          (let ((end (save-excursion
                       (outline-next-heading)
                       (point)))
                begin)
            (goto-char (line-beginning-position))
            (setq begin (point))
            (when (re-search-forward state-regexp end t)
              (let* ((time-string (match-string 2))
                     (when-closed (org-parse-time-string time-string)))
                (if (>= (time-to-number-of-days
                         (time-subtract (current-time)
                                        (apply #'encode-time when-closed)))
                        mrb/org-my-archive-expiry-days)
                    (org-archive-subtree)))))))))

  (defalias 'archive-done-tasks 'mrb/org-my-archive-done-tasks)

  ;; Map it to Ctrl-C S in orgmode (consider a global key assignment?
  (define-key org-mode-map "\C-cs" 'mrb/shortenurl-replace-at-point)
  ;; END shorten url functionality

  (add-to-list 'load-path "~/dev/emacs/packages/org-bom/")
  (require 'org-bom)

  ;; archive entries into a date-tree
  ;; (setq org-archive-location "%s_archive::date-tree")
  (defadvice org-archive-subtree
    (around org-archive-subtree-to-data-tree activate)
    "org-archive-subtree to date-tree"
    (if
        (string= "date-tree"
                 (org-extract-archive-heading
                  (org-get-local-archive-location)))
        (let* ((dct (decode-time (org-current-time)))
               (y (nth 5 dct))
               (m (nth 4 dct))
               (d (nth 3 dct))
               (this-buffer (current-buffer))
               (location (org-get-local-archive-location))
               (afile (org-extract-archive-file location))
               (org-archive-location
                (format "%s::*** %04d-%02d-%02d %s" afile y m d
                        (format-time-string "%A" (encode-time 0 0 0 d m y)))))
          (message "afile=%s" afile)
          (unless afile
            (error "Invalid `org-archive-location'"))
          (save-excursion
            (switch-to-buffer (find-file-noselect afile))
            (org-datetree-find-year-create y)
            (org-datetree-find-month-create y m)
            (org-datetree-find-day-create y m d)
            (widen)
            (switch-to-buffer this-buffer))
          ad-do-it)
      ad-do-it))

  ;;
  ;; Org-mobile configuration
  (setq
   ; Remote org dir
   ;;org-mobile-directory "/plato.hsdev.com:/home/mrb/data/mobileorg"
   ; Where to place items which need resolving
   org-mobile-inbox-for-pull (concat org-metadir "from-mobile.org")
   ; No id yet, don't see the advantage yet
   org-mobile-force-id-on-agenda-items nil
   ; No encryption (yet)
   org-mobile-use-encryption nil
   org-mobile-agendas (quote all)
   org-mobile-files
   (quote (
           "~/.outlet/GTD.org"
           "~/.outlet/habits.org"
           "~/.outlet/_calendars/meetings.org"))
   org-mobile-use-encryption nil
  )

  ;; Define timer variables for pull and push operations
  (defvar org-mobile-push-timer nil)
  (defvar org-mobile-pull-timer nil)

  ;; Define notificaters
  (require 'notifications)

  (defun org-mobile-notify (type result)
    (notifications-notify
     :title (concat type " complete:")
     :body  (format (concat "Org-mobile-" type ": %s") result)))

  (defun notify-push (result) (org-mobile-notify "Push" result))
  (defun notify-pull (result) (org-mobile-notify "Pull" result))

  ;; Fork the work of pushing to mobile
  (defun fork-org-mobile-push()
    (async-start
     ;; What to do in the child process
     `(lambda ()
        ,(async-inject-variables "org-\\(mobile-\\|directory\\)")
        (org-mobile-push))

     ; What to do when it finishes
     (lambda (result)
       (notify-push result)
       (message "Push of mobile org complete"))))

  ;; Push to mobile when the idle timer runs out
  (defun org-mobile-push-with-delay (secs)
    (when org-mobile-push-timer
      (cancel-timer org-mobile-push-timer))
    (setq org-mobile-push-timer
          (run-with-idle-timer
           (* 1 secs) nil 'fork-org-mobile-push)))

  ;; After saving files, start a 30 seconds idle timer after which we
  ;; are going to push
  ;; (add-hook
  ;;  'after-save-hook
  ;;  (lambda ()
  ;;    (when (eq major-mode 'org-mode)
  ;;      (dolist (file (org-mobile-files-alist))
  ;;        (if (string= (expand-file-name (first file)) (buffer-file-name))
  ;;         (org-mobile-push-with-delay 30))))))

  ;; Fork the work of pushing to mobile
  (defun fork-org-mobile-pull ()
    (async-start
     ;; What to do in the child process
     `(lambda ()
        ,(async-inject-variables "org-\\(mobile-\\|directory\\)")
        (org-mobile-pull))

     ; What to do when it finishes
     (lambda (result)
       (notify-pull result)
       (message "Pull of mobile org complete"))))

  ;; Construct the name of the remote file
  (setq remote-org-mobile-file
        (file-truename
         (concat
          (file-name-as-directory org-mobile-directory)
          "mobileorg.org")))

  ;; Pull by monitoring the file mobile-org writes to
  (defun install-monitor (file secs)
    ;; Cancel an existing timer, if any
    (when org-mobile-pull-timer
      (cancel-timer org-mobile-pull-timer))
    ;; And set up a new one
    (setq org-mobile-pull-timer
          (run-with-timer
           0 secs
           (lambda (f p)
             ;; If the remote file has been changed within out repeat
             ;; period, we need a new copy
             (unless (< p (second (time-since (elt (file-attributes f) 5))))
               (fork-org-mobile-pull)))
           file
           secs)))

  ;; Install a monitor on the remote org file. Don't make the time too
  ;; short, otherwise the file might nog get pulled in.
  ;; (install-monitor remote-org-mobile-file 30)

  ;; Mail facilities related to org-mode
  (require 'org-mime)

  ;; Small bit to mail an org subtree
  (defun mrb/mail-subtree-from-org ()
    (interactive)
    (if (equal major-mode 'org-agenda-mode)
        (org-agenda-goto)
      )
    ;;TODO: make this also use the mailcompose frame
    (org-mime-subtree))

  ;; The entry point
  (defun mrb/construct-mail (useOrgTree)
    (interactive "P")
    (if useOrgTree
        (mrb/mail-subtree-from-org)
      (make-mailcompose-frame)))
  ;; Bind it to \C-xm in org-mode only
  (define-key org-mode-map "\C-xm" 'mrb/construct-mail)
  (define-key org-agenda-mode-map "\C-xm" 'mrb/construct-mail)
  ;; But not for all others, because the org subtree will never be there
  (global-set-key (kbd "\C-xm") 'make-mailcompose-frame)


  (require 'stripe-buffer)
  (defun mrb/enable-org-table-striping ()
    (interactive)
    (stripe-org-tables-enable))
  ;; TODO I want to have this in the agenda mode to
#+END_SRC

**** Encrypting information in org-mode
I use the /encrypt/ tag for encrypting sections in org-mode (and
sometimes my journal). The sections get encrypted and decrypted
automatically on saving and opening. This uses the EasyPG library to
get to my GPG key.

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-crypt-tag-matcher "encrypt")
(setq org-crypt-key "<marcel@hsdev.com>")
#+END_SRC

This is mostly used for storing things like backup keys for 2-step
authenticationn services etc. This setting does not play very nice
with =auto-save-default= having any other value than =nil=. This was
already my setting, but it can't hurt to set it here too.

#+BEGIN_SRC emacs-lisp
(setq auto-save-default nil)

#+END_SRC

Furthermore, we do not want to inherit this tag automatically, as its
behaviour is already subsection inclusive. When you encrypt a
section, everything below it is considered content of that section
and gets encrypted. I also add the value "crypt" as that is the org
default, so it won't be inherited by mistake.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-tags-exclude-from-inheritance (quote "encrypt"))
(add-to-list 'org-tags-exclude-from-inheritance (quote "crypt"))
#+END_SRC

**** Commiting automatically
I have lost a number of changes in the past because I reverted a
file, made a mistake or whatever. Some of these mistakes can be
reverted easily if saves are automatically committed

Rather than using an after save hook, there is a minor
git-auto-commit mode package which does just what I need.

There is not much to configure for this minor mode. There are a couple
of ways to enable it:
1. file-local variable (put it in the file to be autocommitted)
2. directory-local variable (make a =.dir-locals.el= file); this
   enables it for all files in the directory
3. as a hook

I'm using the first method on relevant files. The disadvantage of
this method is that you have to think about it for each file, so
perhaps a =.dir-locals.el= is a better solution.

I am considering using a generic hook again to enable the method and
either using =git commit --amend= and commit squashing if working on
more structured commits. For files that I really do not want
autocommit to run I can use a file local variable to disable the hook
(or the minor mode)
*** OpenSCAD
OpenSCAD mode, it’s a mode for files that describe 3D-models. I use it
for part design for the 3D-print and for the lathe.
#+BEGIN_SRC emacs-lisp
  ; OpenSCAD has git repository in my dev tree
  (add-to-list 'load-path "~/dev/reprapping/openscad/contrib")
  (load "scad-mode")

  (provide 'openscad)

#+END_SRC
*** Python
Python is a indent aware language, wich saves quite a bit of fiddling
around with parenthes and what have you.

Having lines truncated is the preferred way in python, usually lines
will be short enough anyway, but I can't have line automatically
folding because that disturbs the way I think when looking at python
code.

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook
            (lambda ()
              (toggle-truncate-lines t)))
#+END_SRC
** LDAP
LDAP integration, mostly for address book lookups
#+BEGIN_SRC emacs-lisp
  ; LDAP integration

  (setq ldap-host-parameters-alist
        (quote (("ldap.hsdev.com" base "ou=addressbook,dc=hsdev,dc=com"))))

  (require 'ldap)
  (require 'eudc)

  (setq eudc-default-return-attributes nil
        eudc-strict-return-matches nil)

  (setq ldap-ldapsearch-args (quote ("-tt" "-LLL" "-x")))
  (setq eudc-inline-query-format '((name)
                                   (firstname)
                                   (firstname name)
                                   (email)
                                   ))


  (eudc-set-server "ldap.hsdev.com" 'ldap t)
  (setq eudc-server-hotlist '(("ldap.hsdev.com" . ldap)))
  (setq eudc-inline-expansion-servers 'hotlist)

  (defun enz-eudc-expand-inline()
    (interactive)
    (move-end-of-line 1)
    (insert "*")
    (unless (condition-case nil
                (eudc-expand-inline)
              (error nil))
      (backward-delete-char-untabify 1))
    )

  ;; Adds some hooks

  (eval-after-load "message"
    '(define-key message-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
  (eval-after-load "sendmail"
    '(define-key mail-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
  (eval-after-load "post"
    '(define-key post-mode-map (kbd "TAB") 'enz-eudc-expand-inline))

#+END_SRC
** Key and mouse bindings
Keyboard binding are the primary way to interact for me. I have been
struggling with consistent keyboard shorcuts and how to integrate
them with the nother systems on my machine which capture
shortcut keys. At this time the following applications capture
shortcut keys:
1. the awesome window manager captures keys;
2. xbindkeys provides a number of key bindings for application
   dependent operations;
3. emacs (and obviously all other applications, but those are largely
   irrelevant).
4. the X-windows server has the kbd extension which has some keyboard
   related things to configure.
5. The linux kernel provides key mapping, so I have to look at that
   place too (xmodmap)

Because I am daft, here is the notation for the modifiers:
- C - :: control
- s - :: super, meaning the (left) windows key in my configuration
- M - :: meta, meaning the (left) alt key in my configuration
- S - :: shift

To help me out with this when writing about key bindings, the lisp
function =key-description= can help out, with a little bit of glue
around it:

#+BEGIN_SRC emacs-lisp
  (defun mrb/insert-key-description ()
    "Insert a pretty printed representation of a key sequence"
    (interactive)
    (insert (key-description (read-key-sequence "Type a key seqence:"))))
#+END_SRC
I like the explicit notation where the name of the key is spelled out
better, and I'll move all configured keybindings to that eventually.

The right alt and the right <menu> key should be the same as the left
alt and the super key, but I haven't gotten around to configuring
that yet.

*** First, unsetting the keys I don't want.
Let's begin with killing some bindings which are in my way, notably
the standard right mouse click behaviour. This is because I want it
to behave in org-mode, which apparently sets this. I should probably
find out a better way for this.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "<mouse-3>"))
#+END_SRC
*** Setting keys
This is the remnant of my old configuration.
#+BEGIN_SRC emacs-lisp
  ; Let marks be set when shift arrowing, everybody does this
  ;; FIXME: this does not belong in keybindings, but somwhere global
  (setq shift-select-mode t)
  (delete-selection-mode 1)

  ; Font scaling, like in chrome
  (global-set-key [(super =)] 'text-scale-increase)
  (global-set-key [(super -)] 'text-scale-decrease)
  ; Font scaling, like in firefox
  (global-set-key [(control +)] 'text-scale-increase)
  (global-set-key [(control -)] 'text-scale-decrease)

  ; Line handling functions
  ;; For external keyboard FIXME: these bindings contain dead characters
  ;; if such a keyboard is used, which can be confusing.
  (global-set-key [(?\s-\§)] 'toggle-truncate-lines)
  ;; For t510 keyboard (the same place)
  (global-set-key [(super \`)] 'toggle-truncate-lines)

  ;; Most of the time I want return to be newline and indent
  ;; Every mode can augment this at will obviously (org-mode does, for example)
  (global-set-key (kbd "RET") 'newline-and-indent)

  ;; Comment code lines, command reacts based on the major mode.
  (global-set-key [(super /)] 'comment-or-uncomment-region)

  (global-set-key [(super s)] 'save-buffer)

  ;; Kill buffer, FIXME: asks for name, which I dont need
  (global-set-key [(super k)] 'ido-kill-buffer)

  ;; Resizing windows
  ;; Introduce a bit of intelligence so the shrink and enlarge know what window I'm in.
  (defun xor (b1 b2)
    "Exclusive or between arguments"
    (or (and b1 b2)
        (and (not b1) (not b2))))

  (defun move-border-left-or-right (arg dir)
    "General function covering move-border-left and move-border-right. If DIR is
    t, then move left, otherwise move right."
    (interactive)
    (if (null arg) (setq arg 5))
    (let ((left-edge (nth 0 (window-edges))))
      (if (xor (= left-edge 0) dir)
          (shrink-window arg t)
        (enlarge-window arg t)))
    )

  (defun move-border-left (arg)
    (interactive "P")
    (move-border-left-or-right arg t))

  (defun move-border-right (arg)
    (interactive "P")
    (move-border-left-or-right arg nil))

  ;; Same for up and down
  (defun move-border-up-or-down (arg dir)
    "General function covering move-border-up and move-border-down. If DIR is
    t, then move up, otherwise move down."
    (interactive)
    (if (null arg) (setq arg 5))
    (let ((top-edge (nth 1 (window-edges))))
      (if (xor (= top-edge 0) dir)
          (shrink-window arg nil)
        (enlarge-window arg nil))))

  (defun move-border-up (arg)
    (interactive "P")
    (move-border-up-or-down arg t))

  (defun move-border-down (arg)
    (interactive "P")
    (move-border-up-or-down arg nil))


  ;; cut, copy and paste with cmd-key (like on osx).
  ;; this kinds sucks now, because the rest of the OS does not do this
  ;; SOLUTION: learn to work with standard emacs keybinding and adjust the OS  ?
  (global-set-key [(super z)] 'undo)
  (global-set-key [(super x)] 'clipboard-kill-region)
  (global-set-key [(super c)] 'clipboard-kill-ring-save)
  (global-set-key [(super v)] 'yank)
  (global-set-key [(super a)] 'mark-whole-buffer)

  ;; Keypad delete
  (global-set-key [(kp-delete)] 'delete-char)

  ;; Make `C-x C-m' and `C-x RET' be different (since I tend
  ;; to type the latter by accident sometimes.)
  ;; Should this not be an unset?
  (global-set-key [(control x) return] nil)

  (defun new-empty-buffer ()
    "Opens a new empty buffer."
    (interactive)
    (let ((buf (generate-new-buffer "untitled")))
      (switch-to-buffer buf)
      (make-frame)
      (funcall (and initial-major-mode))
      (setq buffer-offer-save t)))
  ;; note: emacs won't offer to save a buffer that's
  ;; not associated with a file,
  ;; even if buffer-modified-p is true.
  ;; One work around is to define your own my-kill-buffer function
  ;; that wraps around kill-buffer, and check on the buffer modification
  ;; status to offer save
  ;; This custome kill buffer is close-current-buffer.
  (global-set-key [(super n)] 'new-empty-buffer)

#+END_SRC
*** Key bindings
**** Global
I am running the emacs daemon and sometime when I quit emacs, I want
it to quit too. This sounds a bit counterintuitive, but as long as my
emacs config is moving and I am not proficient enough in making sure I
can apply the changed settings reliably from within emacs, restarting
emacs is just easier. This saves me from having to kill the emacs
daemon from the terminal.

#+BEGIN_SRC emacs-lisp
  (global-set-key [(control x) (control q)] 'save-buffers-kill-emacs)
#+END_SRC

Probably the most important key is =M-x= (as set by default). That key
gives access to other commands within emacs, so it better be
effective. If I wasn't already used to it, I'd certainly not consider
=M-x= as a first candidate. The main objection I have is that the two
keys are close to eachother, making it hard to press in a typing flow.

I like the incremental matching that smex does, so I am going to
rebind the M-x keybinding to that, and rebind the original to have
C-c as a prefix. Using the shift modifier with the M-x command also
runs smex, but limits the commands to make sense for the current
major mode only.
#+BEGIN_SRC emacs-lisp
  (global-set-key [(control c)(meta x)] 'execute-extended-command)
  (global-set-key [(meta x)] 'smex)
  (global-set-key [(meta X)] 'smex-major-mode-commands)
#+END_SRC

I want to be able to call up magit from anywhere
#+BEGIN_SRC emacs-lisp
  (global-set-key [(control c) m] 'magit-status) ;; Does not work for some reason
  (global-set-key (kbd "C-c m") 'magit-status)
#+END_SRC
***** COMMENT Special keys
For some special keys I have defined some commands. Special keys are
those keys that may not be on every keyboard, within reason. I
consider the function keys also as special, although they do not fit
the previous definition.

#+BEGIN_SRC emacs-lisp
  ;; Menu key does M-x, if we have it.
  ;;(global-set-key (kbd "<apps>") 'execute-extended-command)
  (global-set-key [f1] 'help-command)
  (global-set-key [f2] 'save-buffer)
  (global-set-key [f3] 'find-file)

  ;; Define the toggle-frame-fullscreen function in
  ;; the case that it is not already.

  (if (not (fboundp 'toggle-frame-fullscreen))
      (defun toggle-frame-fullscreen()
        (interactive)
        (when (eq window-system 'x)
          (set-frame-parameter
           nil 'fullscreen
           (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))))

  ;; Make gnome compliant, define a full-screen function and bind to F11
  (defun mrb/switch-full-screen ()
    (interactive)
    (toggle-frame-fullscreen))
  (global-set-key [f11] 'mrb/switch-full-screen)

  ;; Not sure what this is? It is not the menu key.
  (global-set-key [XF86MenuKB] 'accelerate-menu)
  (global-set-key [XF86Battery] 'display-battery-mode)
#+END_SRC

***** Resizing and switching windows and frames
#+BEGIN_SRC emacs-lisp
  ;; Moving back and forth in windows For now, I'm using the Fn Key +
  ;; Arrows, seems consistent with the other window movements
  (global-set-key [XF86AudioNext] 'next-multiframe-window)
  (global-set-key [XF86AudioPrev] 'previous-multiframe-window)

  ;; Alt-Cmd left-right arrows browse through buffers within the same frame
  (global-set-key [(meta super left)] 'previous-buffer)
  (global-set-key [(meta super right)] 'next-buffer)

  ;; Ctrl Cmd moves buffers up and down in the tiling of emacs
  (global-set-key [(control super up)]   'buf-move-up)
  (global-set-key [(control super down)] 'buf-move-down)

  ;; These would conflict with awesome bindings, perhaps we should change those bindings
  ;; (global-set-key (kbd "<C-S-left>")   'buf-move-left)
  ;; (global-set-key (kbd "<C-S-right>")  'buf-move-right)

  ;; Use Super + Arrows to steer the borders
  (global-set-key [(super up)] 'move-border-up)
  (global-set-key [(super down)] 'move-border-down)
#+END_SRC
**** Mode specific
***** Org-mode
#+BEGIN_SRC emacs-lisp
  (global-set-key [(control c) (g)] 'gtd)
  (global-set-key [(control c) (a)] 'org-agenda)
  (global-set-key [(control c) (b)] 'org-iswitchb)
  (global-set-key [(control c) (l)] 'org-store-link)
  (global-set-key [(control c) (j)] 'make-journal-entry)
#+END_SRC

***** Identica-mode
#+BEGIN_SRC emacs-lisp
  (global-set-key [(control c) (ip)] 'identica-update-status-interactive)
  (global-set-key [(control c) (id)] 'identica-direct-message-interactive)
  (global-set-key [(control c) (is)] 'identica-shortenurl-replace-at-point)
  (global-set-key [(control c) (d)]  'make-dent-frame)
#+END_SRC

** Terminals, Character encodings and emulation
My policy is to use Emacs for as many things and use as little
programs as necessary. All this within reason obvously.

This sections describes how terminals and shells are used from within
Emacs. In an ideal situation I won't be needing any other terminal
emulator program, other than the ones used directly from Emacs.

At the momen I use two varieties:
1. Ansi terminal; basically a front-end to =/bin/bash=
2. Eshell; the all Emacs-Lisp based solution.

*** Ansi term
#+BEGIN_SRC emacs-lisp
  (defun mrb/use-utf8 ()
    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
  (add-hook 'term-exec-hook 'mrb/use-utf8)

  ;; Define terminal config, I prefer ansi-term
  (require 'term)
  (defun mrb/ansi-term (&optional new-buffer-name)
    "Start a terminal-emulator in a new buffer."
    (interactive)

    (setq program "/bin/bash")

    ;; Pick the name of the new buffer.
    (setq term-ansi-buffer-name
          (if new-buffer-name
              new-buffer-name
            (if term-ansi-buffer-base-name
                (if (eq term-ansi-buffer-base-name t)
                    (file-name-nondirectory program)
                  term-ansi-buffer-base-name)
              "ansi-term")))

    (setq term-ansi-buffer-name (concat "*" term-ansi-buffer-name "*"))

    ;; In order to have more than one term active at a time
    ;; I'd like to have the term names have the *term-ansi-term<?>* form,
    ;; for now they have the *term-ansi-term*<?> form but we'll see...

    (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
    (setq term-ansi-buffer-name (term-ansi-make-term term-ansi-buffer-name program))

    (set-buffer term-ansi-buffer-name)
    (term-mode)
    (term-char-mode)

    ;; Go there
    (switch-to-buffer term-ansi-buffer-name))

  ; Aliases
  (defalias 'at 'mrb/ansi-term)

  ;; When closing the ansi term window, close the useless buffer too
  (defadvice term-sentinel (around mrb/advice-term-sentinel (proc msg))
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))
  (ad-activate 'term-sentinel)
#+END_SRC handling.
*** Eshell
Eshell is theoretically the ideal shell; part of emacs, completely
implemented in lisp and thus available regardless of the underlying
hardware and operating system. In practice, many things won't work as
expected.

In the window manager (awesome-wm) 'Cmd Enter' launches a terminal,
similarly within Emacs 'C-c Enter' launches Eshell:
#+BEGIN_SRC emacs-lisp
  (define-key global-map [(control c) return] 'eshell)
#+END_SRC

First thing I missed in eshell was a the =clear= function, as in
bash. By defining a function in the "eshell namespace" it gets
registered as a command automatically.
#+BEGIN_SRC emacs-lisp
(defun eshell/clear ()
  "Clears the shell buffer as in bashes clear"
  (interactive)
  ;; clear read-only of prompts
  (let ((inhibit-read-only t))
	(delete-region (point-min) (point-max))))
#+END_SRC

Set the main directory for eshell, I do not want in in the default
place but below the .emacs.d directory where all other configuration
of emacs stuff is.
#+BEGIN_SRC emacs-lisp
  (setq eshell-directory-name (concat emacs-directory "eshell/"))
#+END_SRC

A list of functions / filters through which interactive output is
passed, most of this was copied from the default for adjustment
here. I have not actually changed anything myself.
#+BEGIN_SRC emacs-lisp
  (setq eshell-output-filter-functions
        (quote
         (eshell-handle-ansi-color
          eshell-handle-control-codes
          eshell-watch-for-password-prompt
          eshell-handle-control-codes
          eshell-handle-ansi-color
          eshell-watch-for-password-prompt)))
#+END_SRC

As I am migrating from bash, I want eshell to behave as much like
bash as possible. The next settings take care of some of the things
to make that happen.
#+BEGIN_SRC emacs-lisp
;; Do completions, but don't cycle
(setq eshell-cmpl-cycle-completions nil)

;; Completion ignores case
(setq eshell-cmpl-ignore-case t)

;; scroll to the bottom
(setq eshell-scroll-to-bottom-on-output t)
(setq eshell-scroll-show-maximum-output t)
(add-to-list 'eshell-output-filter-functions 'eshell-postoutput-scroll-to-bottom)
#+END_SRC

Another step closer to a full terminal replacement is to be able to
replace lxterminal (my terminal emulator in use now). This requires a
number of parts:
1. something to call from the commandline instead of lxterminal
2. a lisp function which takes care of the passthrough to eshell,
   creating the frame, etcetera.

The calling part is simpel:
#+BEGIN_SRC sh
emacsclient -a "" -n -c -e '(server-eshell)'
#+END_SRC

The last bit of that command line is the function to evaluate, which
was taken from http://ur1.ca/cf1m4 and sligthly adapted.
#+BEGIN_SRC emacs-lisp
  (require 'cl)

  (defun server-eshell ()
    "Command to be called by emacs-client to start a new shell.

  A new eshell will be created. When the frame is closed, the buffer is deleted or the shell exits,
  then hooks will take care that the other actions happen. For example, when the frame is closed,
  then the buffer will be deleted and the client disconnected.
  "
    (lexical-let ((buf (eshell t))
                  (client (first server-clients))
                  (frame (selected-frame)))
      (cl-labels ((close (&optional arg)
                  (when (not (boundp 'cve/recurse))
                    (let ((cve/recurse t))
                      (delete-frame frame)
                      (kill-buffer buf)
                      (server-delete-client client)))))
      (add-hook 'eshell-exit-hook #'close t t)
      (add-hook 'delete-frame-functions #'close t t))
      (delete-other-windows)
      nil))
#+END_SRC
** Completion
I want completion to work as follows:

1. completion functions are always bound to a keybinding involving the
   TAB-key , with as little modifiers as possible;
2. completion should *always* produce *something*, even if emacs has no
   special semantic knowledge of the current mode, it should produce
   /something/ which makes sense;
3. for each mode, a specialization is ok, if that improves the
   situation; I expect to have many specialisations to improve the
   autocomplete quality;
4. completion should be inline whenever possible.
5. if a completion window *must* be openened, do this at the same place
   always and do not mess up other windows.
6. Completion should behave somewhat like real-time systems. An
   answer *must* be produced within a certain amount of time. If a
   completion answer takes longer than the amount of type to type it
   in full, the system has collapsed, so the time needs to be in the
   order of one third of the typing time.

The next secions deal with the above requirments
*** Ad 1. Bind completion always involves TAB-key
The package =smart-tab= seems to fit this bill.

Once activated, the default behaviour, if not specified otherwise, is
to call dabbrev-expand. A more elaborate function is hippie-expand,
which tries various methods.
#+BEGIN_SRC emacs-lisp
  (require 'smart-tab)
  (setq smart-tab-using-hippie-expand t)
#+END_SRC
*** Ad 2. Completion should always produce something
This is just a matter of enabling smart-tab globally.

#+BEGIN_SRC emacs-lisp
  ;; Enable everywhere
  (global-smart-tab-mode 1)
#+END_SRC
*** Ad 3. Mode specialisation
Be smart with tabs and try to have the tab key do the sensible
thing. The list below contains things the tab key should do in certain
modes if it does not already. The second part is the exclusion list
where the sensible thing the =smart-tab= mode provides is not sensible
at all.

#+BEGIN_SRC emacs-lisp
  (require 'smart-tab)
  ;; Make sure it does the right thing in some modes
  (add-to-list 'smart-tab-completion-functions-alist '(emacs-lisp-mode . lisp-complete-symbol))
  (add-to-list 'smart-tab-completion-functions-alist '(text-mode . dabbrev-completion))
  (add-to-list 'smart-tab-completion-functions-alist '(erc-mode . pcomplete))

  ;; Disable it in org-mode, tab is heavily customized there (org-cycle)
  (add-to-list 'smart-tab-disabled-major-modes 'org-mode)
  (add-to-list 'smart-tab-disabled-major-modes 'org-agenda-mode)

  ;; eshell gets very confused if smart-tab is enabled
  (add-to-list 'smart-tab-disabled-major-modes 'eshell-mode)

  ;; Similarly, term-mode doesn't like it either
  (add-to-list 'smart-tab-disabled-major-modes 'term-mode)
#+END_SRC
*** Ad 4. Inline completion when possible
What I want:
- languages: lisp, python, ruby, bash, C/C++ roughtly in that order
- for all languages, function/method signature shorthands
- speed, slowness is killing here

Candidates:
- auto-complete :: http://cx4a.org/software/auto-complete/

I have a feeling auto-complete will be slow and I will get annoyed by
the window popping up on the screen, but let's see if configuration
could be made such that it is usable for me.

Starting with the default config, which should probably work for most
situations. The good news is that smart-tab seems to be auto-complete
aware so we should be good to go.
#+BEGIN_SRC emacs-lisp
(require 'auto-complete-config)
(ac-config-default)
#+END_SRC

*** Ad 5. Open completion window predictably
Completion normally opens a special window like **Completions** for
example. The =popwin= package make this behaviour a bit more
predictable by showing it in the same place and making sure I can get
rid of it easily.

#+BEGIN_SRC emacs-lisp
(require 'popwin)
(setq display-buffer-function 'popwin:display-buffer)
#+END_SRC
*** Ad 6. Guaranteed response-time
I haven't found a solution for this yet.

** Editing control

I like to do thing interactively where I can:
#+BEGIN_SRC emacs-lisp
(require 'ido)
(ido-mode t)
(setq ido-enable-flex-matching t) ;; enable fuzzy matching
(ido-everywhere)
#+END_SRC


By selecting a piece of text, wrap-region can quote or otherwise
delimit that region automatically. I enable this globally. There is
an option to configure in exception, which I have commented out as
I've found none applicable yet.
#+BEGIN_SRC emacs-lisp

(require 'wrap-region)
(wrap-region-global-mode 1)
;; (add-to-list 'wrap-region-except-modes 'conflicting-mode)
#+END_SRC
** Remote editing
#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "sshx")
#+END_SRC

** Browser integration
My default browser, as set in the OS, is chromium. Yet, emacs needs
an explicit mention, otherwise it will start firefox. Not sure why
that is.
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function (quote browse-url-generic))
(setq browse-url-generic-program "x-www-browser")
#+END_SRC

** Messaging and chatting
*** ERC
ERC is an irc implementation within emacs. When I start erc I want to
connect automatically the configured servers without having to enter
nicks and passwords and stuff.

Start by configuring some basic settings
#+BEGIN_SRC emacs-lisp
  (require 'erc)
  (require 'erc-tweet)
  (require 'erc-image)

  (setq
   erc-modules (quote (
                       autojoin button completion fill
                                irccontrols keep-place list log
                                match menu move-to-prompt netsplit
                                networks noncommands notify readonly
                                replace ring smiley stamp track unmorse highlight-nicknames smiley
                                tweet image))
   erc-image-inline-rescale 150
   )
#+END_SRC

Configure erc to use services and automatically identify my Nicks to
Nickserv.
#+BEGIN_SRC emacs-lisp
  (require 'erc-services)
  (setq erc-nick '("Marcel|HSD" "Marcel||HSD"))

  (setq erc-prompt-for-nickserv-password nil)
  (erc-services-mode 1)
#+END_SRC

These are the channels I visit regularly, maintain a list of
them. (Perhaps this should be outside of this config to be more
flexible) The meaning here is that *when* I connect to a server which
matches the expression in the first part of the list, it autojoins
the channels in the rest of the list. This does not connect to a
server by itself.
#+BEGIN_SRC emacs-lisp
  (setq erc-autojoin-channels-alist
        '((".*\\.freenode.net" "#openobject" "#social")))
#+END_SRC

After joining, ERC keeps track of the channels, by putting notifiers
in the modeline. I am not interested in some of the things happening
in the channels.
#+BEGIN_SRC emacs-lisp
(erc-track-mode t)
(setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                 "324" "329" "332" "333" "353" "477"))
(setq erc-hide-list '("JOIN" "PART" "QUIT" "NICK"))
#+END_SRC

Log every channel in a simple =#channel-date.txt= file.
#+BEGIN_SRC emacs-lisp
  (setq erc-generate-log-file-name-function (quote erc-generate-log-file-name-with-date))
#+END_SRC

Within each channel, I like to change the prompt to the name of the
channel; a quick google search turned out with this code:
#+BEGIN_SRC emacs-lisp
  (setq
   erc-prompt
   (lambda ()
     (if (and
          (boundp 'erc-default-recipients)
          (erc-default-target))
         (erc-propertize
          (concat (erc-default-target) ">")
          'read-only t
          'rear-nonsticky t
          'front-nonsticky t)
       (erc-propertize
        (concat "ERC>")
        'read-only t
        'rear-nonsticky t
        'front-nonsticky t)
       )
     )
   )

#+END_SRC

Define a function to start erc, so I can start it the way I like it.
#+BEGIN_SRC emacs-lisp
  (defun mrb/erc ()
    "Wrapper to start erc in the way I want it"
    (interactive)

    ;;I use freenode for most things
    (erc-tls :server "irc.freenode.net" :port 7000))
#+END_SRC
*** Mail
Mail configuration.
#+BEGIN_SRC emacs-lisp
  (setq
   ; User agent style is message mode (gnus, but independent of it)
    mail-user-agent 'message-user-agent

    ; Sending it
    smtpmail-default-smtp-server "localhost"
    smtpmail-smtp-service 24
    smtpmail-local-domain "hsdev.com"
    smtpmail-sendto-domain "hsdev.com"
    send-mail-function 'smtpmail-send-it                 ; This is for mail
    message-send-mail-function 'message-smtpmail-send-it ; This is for gnus

    ; Always put one in the Sent folder on sending
    message-default-mail-headers "Bcc: mrb+Sent@hsdev.com\n"
    mail-yank-prefix ">> "
  )
  ;; Automatically sign outgoing messages, be part of the solution here,
  ;; not the problem
  ;; TODO: where can I toggle this on/off while composing?
  ;;(setq smime-keys (quote (("marcel@hsdev.com" "~/keys/comodo-2012-06-12.pem" nil))))
  ;;(add-hook 'message-send-hook 'mml-secure-message-sign-smime)
  (setq password-cache t)            ; default is true, so no need to set this actually
  (setq password-cache-expiry 28800) ; default is 16 seconds, which is ridiculously low
  (require 'smtpmail)

  ;;(add-hook 'message-mode-hook 'orgstruct++-mode 'append)
  (add-hook 'message-mode-hook 'turn-on-auto-fill 'append)
#+END_SRC

I think I might light mu4e use once in a while, so let's set up a
configuration for that as well.
#+BEGIN_SRC emacs-lisp
    (require 'mu4e)

    (setq
     mu4e-maildir "~/Maildir"
     mu4e-sent-folder "/.Sent"
     mu4e-drafts-folder "/.Drafts"
     mu4e-trash-folder "/.Trash"
     mu4e-get-mail-command t
     mu4e-update-interval nil
     mu4e-view-show-images t
     mu4e-view-image-max-width 800
     mu4e-reply-to-address "marcel@hsdev.com")
#+END_SRC

Composing mail is often an /out of band/ activity, like creating a dent
or a capture, so I would like to have roughly the same behaviour. This
is by default provided by commpose-mail-other-frame, but I could not
get awesome to properly place the windows because it's hard to match
on the varying name that xprop delivers, so. we make our own window.

#+BEGIN_SRC emacs-lisp
  (defun make-mailcompose-frame (&optional mailto-url)
    "Create a new frame and run mail-compose, use mailto URI if it is given."
    (interactive)

    ;; Create and select the frame, awesome wm takes care of the
    ;; placement and floating it on top of all other windows.
    (select-frame (make-frame '((name . "mailcompose")
                                (width . 100) (height . 50)
                                (menu-bar-lines . 0) (tool-bar-lines . 0))))

    ;; If we have a mailto argument, parse and use it
    (if (and (stringp mailto-url)
             (string-match "\\`mailto:" mailto-url))
        (progn
          (require 'rfc2368)
          (require 'rfc2047)
          (require 'mailheader)

          (let ((hdr-alist (rfc2368-parse-mailto-url mailto-url))
                (body "")
                to subject
                ;; In addtion to To, Subject and body these headers are
                ;; allowed:
                (allowed-xtra-hdrs '(cc bcc in-reply-to)))
            (with-temp-buffer
              ;; Extract body if it is defined
              (when (assoc "Body" hdr-alist)
                (dolist (hdr hdr-alist)
                  (when (equal "Body" (first hdr))
                    (insert (format "%s\n:" (rest hdr)))))
                (rfc2047-decode-region (point-min) (point-max))
                (setq body (buffer-substring-no-properties
                            (point-min) (point-max)))
                (erase-buffer))

              ;; Extract headers
              (dolist (hdr hdr-alist)
                (unless (equal "Body" (first hdr))
                  (insert (format "%s: %s\n" (first hdr) (rest hdr)))))
              (rfc2047-decode-region (point-min) (point-max))
              (goto-char (point-min))
              (setq hdr-alist (mail-header-extract-no-properties)))

            (setq to (or (rest (assq 'to hdr-alist)) "")
                  subject (or (rest (assq 'subject hdr-alist)) "")
                  hdr-alist
                  (remove nil (mapcar
                               #'(lambda (item)
                                   (when (memq (first item) allowed-xtra-hdrs)
                                     (cons (capitalize (symbol-name (first item)))
                                           (rest item))))
                               hdr-alist)))


            ;; Fill it
            (compose-mail to subject hdr-alist nil nil
                          (list (lambda (string)
                                  (insert string))
                                body))))
      ;; No mailto, argument, just run compose mail
      (compose-mail))

      ;; Delete other windows from the frame we are composing it in.
    (delete-other-windows))

    (defadvice message-kill-buffer (after delete-mailcompose-frame activate)
      "Advise message-kill-buffer to close the frame if it is the capture frame"
      (if (equal "mailcompose" (frame-parameter nil 'name))
          (delete-frame)))
    (defadvice message-send-and-exit (after delete-mailcompose-frame activate)
      "Advise message-send-and-exit to close the frame if it is the capture frame"
      (if (equal "mailcompose" (frame-parameter nil 'name))
          (delete-frame)))
#+END_SRC

To be able to use the =mailcompose-frame= function as a mailto handler we need to be
able to call it from outside of emacs. Let's define a small shell script that
does exactly this. The SRC attributes tangle it into my =bin= directory
where is will be in the path. In the OS, this script will need to be
set as the default mail handler.

#+BEGIN_SRC sh :exports code :tangle ~/bin/mailto-handler :shebang #!/bin/sh
# Emacs mailto URI handler

mailto=$1
mailto="mailto:${mailto#mailto:}"

mailto=$(printf '%s\n' "$mailto" | sed -e 's/[\"]/\\&/g')

# Call the elisp function handling our mailto URI
elisp_expr="(make-mailcompose-frame \"$mailto\")"

# Go
edit --eval "$elisp_expr"

#+END_SRC
*** Statusnet
Statusnet, or perhaps microblog in general settings
#+BEGIN_SRC emacs-lisp
  ; Identica comes directly from its git repository
  (add-to-list 'load-path  "~/dev/emacs/packages/identica-mode")
  (load-library "identica-mode.el")
  (require 'longlines)
  (setq
   statusnet-server "o.mrblog.nl"
   statusnet-access-url "http://o.mrblog.nl/api/oauth/access_token"
   statusnet-authorize-url "http://o.mrblog.nl/api/oauth/authorize"
   statusnet-request-url "http://o.mrblog.nl/api/oauth/request_token"
   identica-username "mrb"
   identica-display-success-messages nil
   identica-soft-wrap-status t
   identica-status-format "%i %s %r: %t"
   identica-timer-interval 120
   identica-update-status-method (quote minibuffer)
   identica-oldest-first nil
   identica-soft-wrap-status nil
   identica-urlshortening-service (quote isgd)
   identica-enable-striping t
   identica-enable-highlighting t
  )



  ;; I'm using a floating frame in awesome WM for dents
  (defun make-dent-frame ()
    "Create a new frame and run identica-update status."
    (interactive)
    ;; Create and select the frame
    (select-frame (make-frame '((name . "dent")
                  (width . 80) (height . 15)
                  (menu-bar-lines . 0) (tool-bar-lines . 0))))
    ;; Capture a Todo entry, force edit-window method
    (identica-update-status 'edit-buffer)

    ;; Once there, make sure we're the only one
    (delete-other-windows)
  )

  ;; Make sure we remove our frame too
  (defadvice identica-update-status-from-edit-buffer-send
    (after delete-dent-frame-on-send activate)
    "Advise to close the frame"
    (if (equal "dent" (frame-parameter nil 'name))
        (delete-frame))
  )
  (defadvice identica-update-status-from-edit-buffer-cancel
    (after delete-dent-frame-on-cancel activate)
    "Advise to close the frame"
    (if (equal "dent" (frame-parameter nil 'name))
        (delete-frame))
  )
#+END_SRC
*** Pump.io
Similar to capturing TODO and BUY entries, there's a way to captur
pump.io entries too.

The only pump.io elisp implementation does almost everything like I
want it to be, including key bindings.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path  "~/.emacs.d/el-get/pump.io/src")
  (require 'pumpio-interface)

  ;; Configure for qua.name
  (setq pumpio-pod "http://qua.name")
  ;; pmpio-client-id: "ElJu_hKISw0xS2aurzxfeQ"
  ;; pmpio-client-secret: "2mcvN7dVLA-WPqWxbJ5L5sz1YFUWx3uvEMyvPu9-dNU"
  (setq pmpio-auth-token
        [cl-struct-oauth-access-token
         "ElJu_hKISw0xS2aurzxfeQ"
         "2mcvN7dVLA-WPqWxbJ5L5sz1YFUWx3uvEMyvPu9-dNU"
         [cl-struct-oauth-t
          "Z96ly0FYf6aOp2_hDiG8_A"
          "dwriXA736awDlYgoVlQREsBtupkmy1pEqYqNeRX1lHk"]])

  ;; I'm using a floating frame in awesome WM for dents
  (defun make-pump-frame ()
    "Create a new frame and run pump postnote"
    (interactive)
    ;; Create and select the frame
    (select-frame (make-frame '((name . "pump")
                                (width . 80) (height . 15)
                                (menu-bar-lines . 0) (tool-bar-lines . 0)))))

  (defun capture-pump ()
    "Capture a pump note"
    (interactive)

    (make-pump-frame)
    (pmpio-ctrl-post-note)

    ;; Once there, make sure we're the only one
    (delete-other-windows)
  )

  ;; Make sure we close our frame
  (defadvice pmpio-ctrl-close-new-note (after delete-pump-frame activate)
    "Advise to close the frame"
    (if (equal "pump" (frame-parameter nil 'name))
        (delete-frame)))
#+END_SRC
*** XMPP
XMPP related settings, including interfacing it to other systems
#+BEGIN_SRC emacs-lisp
  ; Directly tie into the GIT repository on this machine if needed
  (add-to-list 'load-path "~/dev/emacs/packages/emacs-jabber/")
  (add-to-list 'load-path "~/dev/emacs/packages/emacs-jabber/compat/")
  ;;(require 'jabber-autoloads)
  (require 'jabber)

  ; Configuration variables
  (setq
   jabber-show-offline-contacts nil
   jabber-default-priority 30
   jabber-alert-message-hooks
   (quote
    (jabber-message-libnotify
     jabber-message-echo
     jabber-message-scroll))
   jabber-message-alert-same-buffer nil
   jabber-roster-show-bindings nil
   jabber-auto-reconnect t
   jabber-show-resources t
  )
  (setq jabber-account-list (quote (("marcel@hsdev.com/Emacs" (:connection-type . ssl)))))

  ;; Me wants the smileys too
  ;; FIXME: I suspect this makes chats annoyingly slow to type in?
  ;;(require 'autosmiley)
  ;;(add-hook 'jabber-chat-mode-hook 'autosmiley-mode)

  ;; Show some info in the modeline
  (jabber-mode-line-mode 1)

  ;; Do not steal my focus in the mini buffer
  ;; Message alert hooks
  (define-jabber-alert echo "Show a message in the echo area"
    (lambda (msg)
      (unless (minibuffer-prompt)
        (message "%s" msg))))
#+END_SRC
** Development settings
Some settings which aid in development tasks.

Trailing whitespace can sneak into files without knowing it. I could
enable the display of trailing whitespace, but I find that annoying
to look at. Instead I just remove it just before saving a file.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

I'm not sure if this can be set globally like this for all types of
files, but I can't come up with an example where I would like to keep
trailing whitespace, so let's keep this setting and adjust when
needed.

** To organize and properly configure
Multiple cursors sounds interesting

#+BEGIN_SRC emacs-lisp
(require 'multiple-cursors)
#+END_SRC

License templates
#+BEGIN_SRC emacs-lisp
(require 'xlicense)
(setq license-directory (concat emacs-directory "licenses"))
(add-to-list 'license-types '(agpl . "AGPL"))
(setenv "ORGANIZATION" "HS-Development BV")
(setq user-organization "HS-Development BV")
#+END_SRC

Make sure erase works properly, even though I don't understand this,
apparently this is what I need.
#+BEGIN_SRC emacs-lisp
(if window-system  (normal-erase-is-backspace-mode t))
#+END_SRC
*** Google-map
Google map integration for Emacs
#+BEGIN_SRC emacs-lisp
  ; Directly tie into the GIT repository on this machine
  (add-to-list 'load-path "~/dev/emacs/packages/jd-el/")

  (require 'google-maps)

  ; org-mode integration
  (require 'org-location-google-maps)

  (provide 'google-map-settings)

#+END_SRC
*** Quantified Emacs!
Taken from sacha’s configuration, this records which keys I press in
emacs and how often I do that. This is usefull, or may be, for
decisions with respect to keyboard choices, bindings configuration
etc.
#+BEGIN_SRC emacs-lisp
  (require 'keyfreq)
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)
#+END_SRC

The results can be shown by entering =keyfreq-show=.
** Wishlist
There's always more to want, here a quick list of things:
- epub export from org-mode
- a working fill-column indicator which does not kill performance
- specific changes to increase emacs performance, it can be slow at
  times
- doc-view window fitting
- if i had a browser in emacs i could do away with all other programs
  ;-)
- threading or reliable async operation
-
* Self configuration                                                                                 :exclude:
I have the same config file for orgmode itself
#+SETUPFILE: "~/.outlet/etc/org-config.org"

If there is anything that needs to be configured specifically for this
file, here is the place to do it. Other than those, nothing else
should come below this point
