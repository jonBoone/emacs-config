#+TITLE: Emacs configuration
#+DESCRIPTION: An org-babel based emacs configuration
#+LANGUAGE:  en
* Emacs configuration
This is my emacs configuration file that is loaded with
=org-babel-load-file= in the Emacs init file. The intent is to have as
much of my Emacs configuration in here as possible. The system works
as a literal programming system where with a tangle the elisp code
that actually makes up my configuration is extracted automatically
and loaded.

This file was created from many separate elisp files and has not been
fully sanitized yet. Following the history of that may be interesting
to some as well. On top of that I have an auto commit hook on save
running at the moment which does not produce the best hitory
records. All that will change over time.

** Preparing for lift-off
The base of the emacs configuration is in the =~/.emacs.d/= directory,
so add this to my loadpaths first
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/")
#+END_SRC

The first thing I want to take care of is to make customizations
possible and stored in a place to my liking. I want to load this
first so anything in the configuration I define explicitly overrides
it. 
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC

Now that we have the locations of the configuration determined, I want
a way to have them forcibly compiled. 
#+BEGIN_SRC emacs-lisp
  (defun mrb/compile-config ()
    (interactive)
    (org-babel-load-file "~/.emacs.d/mrb.org")
    (byte-recompile-directory "~/.emacs.d" 0)
  )
#+END_SRC

** Personal information
Seems like a good idea to start configuratiion with some details
about me. Just name and email-address for now in public.
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Marcel van der Boom")
  (setq user-mail-address "marcel@hsdev.com")  
#+END_SRC

I need a way to store some sensitive information without that being
published, should I decide some day to push this config somewhere.

One solution is to have all these in a separate file, and not publish
that file. I’m also encrypting the file, as I’m sure I *will* publish
it by accident some day
#+BEGIN_SRC emacs-lisp
(load-library "secrets.el.gpg")
#+END_SRC

** Global Generic settings
#+BEGIN_SRC emacs-lisp
  ;; disable auto-save files (#foo#)
  (setq 
   auto-save-default nil
   
   ; disable backup files (foo~)
   backup-inhibited t
   
   ; disable auto-save-list/.saves
   auto-save-list-file-prefix nil
  
   ; move files to the trash instead of rm
   delete-by-moving-to-trash t
   
   ; use clipboard
   x-select-enable-clipboard t
  
   display-warning-minimum-level 'error
   large-file-warning-threshold nil
   tab-width 4
   find-file-use-truenames nil
   find-file-compare-truenames t
  
   minibuffer-max-depth nil
   minibuffer-confirm-incomplete t
   complex-buffers-menu-p t
   next-line-add-newlines nil
   kill-whole-line t
   truncate-lines t
  )
    
  (global-visual-line-mode 1)
  
  ;; Only require to type 'y' or 'n' instead of 'yes' or 'no' when prompted
  (fset 'yes-or-no-p 'y-or-n-p)
  
  ; Use auto revert mode globally 
  ; This is save because emacs tracks if the file is saved in the editting buffer
  ; and if so, it will not revert to the saved file.
  (global-auto-revert-mode t)
  
  ;; Turn on auto-fill minor mode for all text buffers
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  
  ;; Should this be here?
  ;; Try to have urls and mailto links clickable everywhere
  (define-global-minor-mode global-goto-address-mode
    goto-address-mode
    (lambda ()
      (goto-address-mode 1)))
  (global-goto-address-mode t)  
#+END_SRC
** Packages
Package handling, do this early so emacs knows where to find things.

I want to manage my packages with el-get. This has grown over time,
because el-get has worked well for me so far. I don’t think I have
used the built-in package management of Emacs 24 much.

The *important* bit here is that this section manages *ALL* my packages,
including the ones gotten from apt-get, git and elpa.
The reason for this is that it provides one neat umbrella (in Emacs)
to manage its packages.

We manage everything with =el-get= so we start by loading that

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/el-get/el-get")
  
  (unless  (require 'el-get nil 'noerror)
    (url-retrieve
     "https://github.com/dimitri/el-get.git/raw/master/el-get-install.el"
     (lambda (s)
       (goto-char (point-max))
       (eval-print-last-sexp))))
#+END_SRC

Now, =el-get= is either require’d, and thus available, or loaded by the
el-get installer, in which case it is also available.

The rest is basically a long list of sources for el-get where to get
the packages from and how to install and update them.
When installing a new package, add a recipe in this list, eval it,
and run =el-get-install= with the package name.

#+BEGIN_SRC emacs-lisp
  (setq el-get-sources
        '(
          ;; Obviously we need el-get itself, so we can run a self-update
          ;; There is a recipe, but that is conservative, runs version 3.stable
          (:name el-get :type github :pkgname "dimitri/el-get" :features "el-get")
          ;; Using a different source than the built-in recipe (why was this again?)
          (:name zenburn-emacs :type github :pkgname "bbatsov/zenburn-emacs")
          ;; Version from elpa does not work for me (init problem?)
          smex
          ace-jump-mode
          apache-mode
          (:name cursor-chg :type github :pkgname  "emacsmirror/cursor-chg" :features cursor-chg)
          gnuplot-mode
          sudo-save
          erc-highlight-nicknames
          edit-server
          magit
          markdown-mode
          (:name php-mode-improved)    ; Just to have example for other syntax
          (:name newlua-mode :type github :pkgname "immerrr/lua-mode" :features lua-mode)
          rainbow-delimiters
          (:name typopunct :type github :pkgname "emacsmirror/typopunct" :features typopunct)
          (:name oauth :type github :pkgname "psanford/emacs-oauth")
          scratch
          highlight-parentheses
          (:name expand-region :type github :pkgname "magnars/expand-region.el")
          (:name mark-multiple :type github :pkgname "magnars/mark-multiple.el")
          (:name multiple-cursors :type github :pkgname "magnars/multiple-cursors")
          (:name fixed-point-completion :type github :pkgname "smithzvk/fixed-point-completion")
          (:name xlicense :type github :pkgname "emacsmirror/xlicense")
          (:name autosmiley :type github :pkgname "emacsmirror/autosmiley")
          (:name async :type github :pkgname "jwiegley/emacs-async")
          (:name pcache :type github :pkgname "sigma/pcache")
          (:name logito :type github :pkgname "sigma/logito")
          (:name gh :type github :pkgname "sigma/gh.el" :depends (pcache logito))
          (:name gisthub :type github :pkgname  "defunkt/gist.el" :depends (gh))
          (:name stripe-buffer :type github :pkgname "sabof/stripe-buffer")
          (:name keyfreq :type github :pkgname "dacap/keyfreq")
        )
  )
  (el-get)
#+END_SRC

#+RESULTS:

** Visual 
Many settings have to do with how the screen looks and behaves in a
visual way. Thing like colors, highlighting etc. go fall into this
category.

I enable hightlighting matching parentheses in many levels
globally. I do not know of a situation where not knowing which
bracket or parenthesis goes with which is not a useful thing.

Define the colors for the parentheses at different levels. One catch
here is that the configuration needs one more color than is actually
used. The last entry here does not get highlighted, so my config is
valid for 5 levels, not 6.
#+BEGIN_SRC emacs-lisp
(setq hl-paren-colors (quote ("firebrick" "lightgreen" "orange" "cyan" "yellow" "blue")))
#+END_SRC

And enable the minor mode globally.
#+BEGIN_SRC emacs-lisp
  (define-globalized-minor-mode global-highlight-parentheses-mode
    highlight-parentheses-mode
    (lambda ()
      (highlight-parentheses-mode t)))
  (global-highlight-parentheses-mode t)
  
  ;; 
  ;; Visual customizations, make it look the way I want to
  ;;
  ;; We use a dark background
  (setq-default frame-background-mode 'dark)
  
  ;; no splash screen
  (setq inhibit-startup-screen  t)
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
  
  ;; check speed consequences of this
  (setq column-number-mode t)
  
  ; Zenburn theme with a slightly darker background, the default looks too misty for me
  (defvar zenburn-bg "#303030")
  (defvar zenburn-bg-1 "#303030")
  (load-theme 'zenburn)
  
  ;;
  ;; Zenburn corrections
  ;;
  ;; Adjust the faces for the modeline, mostly for powerline visibility
  (set-face-attribute 'mode-line nil :foreground "white" :background "grey40" :box nil)
  ;; This was the old color
  ;; (set-face-attribute 'mode-line nil :foreground "#4c7073" :box nil)
  (set-face-attribute 'mode-line-inactive nil :box nil)
  ;; Zenburn underlines date face in org, no go
  (set-face-attribute 'org-date nil :underline nil)
  ;; The jabber status is tricky in combination with powerline
  ;;(set-face-attribute 'jabber-roster-user-online nil :foreground "#f9f9f9" :bold t :background "#666666" :inverse-video nil)
  ;; Sometimes the mode-line screws up, this resets it until I have
  ;; found a better solution than a hard reset
  (defun powerline()
    (interactive)
    (load-library "powerline")
  )
  
  ;;
  ;; When I am not typing, the cursor should become more visible, so I
  ;; don't lose it.
  (require 'cursor-chg)                   ; Load this library
  (change-cursor-mode 0)                  ; On for overwrite/read-only/input mode
  (toggle-cursor-type-when-idle 1)        ; On when idle
  (setq curchg-default-cursor-color "LightGreen")
  (setq curchg-default-cursor-type (quote bar\ \.\ 1))
   
  ;; Default frame properties frame position, color, etc
  (setq default-frame-alist
        '((cursor-type . (bar . 1))
          (cursor-color . "LightGreen")
          (height . 60)
          (width . 100)
  ))
  
  ;; Parenthesis matching
  (show-paren-mode 1)
  (setq show-paren-style (quote expression))
  (setq show-paren-delay 0)
  
  ;; As we start emacs in daemon mode, certain (mostly visual) settings
  ;; do not get applied. This is because starting the daemon does not
  ;; open an X connection. This only happens when frames are being
  ;; opened. By adding these settings to the 'server-visit-hook' we can
  ;; still seemingly painless apply these settings.
  (defun run-client-settings()
    (interactive)  
    ;; When making a selection, keep all font-locking too, but make it
    ;; stand out from the matching background
    (set-face-attribute 'region nil :inherit nil :background "gray31" :foreground nil)
  
    ;; Just change the background when matching the expression, leave
    ;; other fontifying as is
    (set-face-attribute 'show-paren-match nil :inherit nil :background "gray10" :foreground nil)
  
    (tool-bar-mode -1)   ;; No tool-bar
    (scroll-bar-mode -1) ;; No scroll-bar
    (menu-bar-mode -1)   ;; No menu-bar
  )
  ;; This seems to work if we start up emacs using filename on cli and
  ;; server was not running yet. It does however not work if we just
  ;; startup emacs (through my edit script) without a filename on the cli 
  (add-hook 'server-visit-hook 'run-client-settings)
  
  ;; Make colorful balanced parentheses etc. in different modes
  (add-hook 'lisp-mode 'rainbow-delimiters-mode)
  
#+END_SRC

** Buffers and files
How do I deal with all those buffers?

For starters, make sure that they have unique buffer names so I don't
get confused:
#+BEGIN_SRC emacs-lisp
  ;; nicer buffer names
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
  #+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; Minibuffer prompt is a prompt, don't enter it as text.
  (setq minibuffer-prompt-properties (quote (read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)))
  
  ;; Save places in buffers between sessions
  (setq-default save-place t)
  (require 'saveplace)
  
  (provide 'buffers)
#+END_SRC
** Modes
Settings about different modes in general. Not specific settings to
one mode in particular.
#+BEGIN_SRC emacs-lisp
  ;;
  ;; Extension mappings
  ;;
  
  ;; First, specify which files to load when functions are called
  (autoload 'markdown-mode "markdown-mode" "Markdown." t)
  (autoload 'gnuplot-mode  "gnuplot"       "GNU-Plot" t)
  (autoload 'php-mode      "php-mode"      "PHP" t)
  (autoload 'css-mode      "css-mode"      "Mode for editing CSS file" t)
  (autoload 'apache-mode   "apache-mode"   "Apache config files" t)
  
  (add-hook 'javascript-mode-hook 'javascript-custom-setup)
      (defun javascript-custom-setup ()
        (moz-minor-mode 1))
  
  ;; Second, specify the extension to function mappings
  (add-to-list 'auto-mode-alist '("\\.org\\'"      . org-mode))
  (add-to-list 'auto-mode-alist '("\\.txt\\'"      . org-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.gp\\'"       . gnuplot-mode))
  (add-to-list 'auto-mode-alist '("\\.php\\'"      . php-mode))
  (add-to-list 'auto-mode-alist '("\\.css$"        . css-mode))
  (add-to-list 'auto-mode-alist '("\\.js$"         . javascript-mode))
  (add-to-list 'auto-mode-alist '("\\.htaccess"    . apache-mode))
  (add-to-list 'auto-mode-alist '("\\.patch"       . diff-mode))
  
  ;; Open scratch buffer by default in the mode we are in at the moment
  ;; with C-u prefix a mode will be asked to use
  (require 'scratch)
  
  ;; Turn on eldoc for modes which support it
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'python-mode 'turn-on-eldoc-mode)
  
  
#+END_SRC 
** Org-mode
Orgmode configuraton
#+BEGIN_SRC emacs-lisp
  ;; Directly tie into the GIT repository on this machine
  ;;(add-to-list 'load-path "~/dev/emacs/packages/org-mode/")
  ;;(add-to-list 'load-path "~/dev/emacs/packages/org-mode/lisp/")
  (add-to-list 'load-path "~/dev/emacs/packages/org-mode/contrib/lisp/")
  (add-to-list 'load-path "~/dev/emacs/packages/org-mode/contrib/babel/langs/")
  
  ;; bootstrap
  ;; CHECKME: is this still the proper installation method, it has changed a lot lately
  (require 'org)           ;; This is required, see installation docs
  (require 'org-clock)             ;; Should not be needed, but otherwise links don't work
  (require 'org-mouse)             ;; Enable menu on right mouse button and other mouse functions
  (require 'org-special-blocks)    ;; Generalizes the #+begin_foo and #+end_foo blocks, useful on latex (export) 
  (require 'org-datetree)          ;; Allows for archiving and refiling in a date organised tree
  (require 'org-mobile)            ;; Only org-mobile-push and pull get autoloaded and we neede the file list before that.
  
  ;; When going into org-mode, do this.
  (defun my-org-init ()
    ;; Autofill is nice when writing larger pieces of text, which I do a lot in org
    (turn-on-auto-fill)
  )
  (add-hook 'org-mode-hook 'my-org-init)
  
  ;;
  ;; General settings
  (setq
   ; Files and directories
   org-directory "~/.outlet/"                                          ; Main dir
   org-metadir (concat org-directory "_orgmeta/")                      ; Org system files go here
   org-archive-location (concat org-metadir "archive.org::date-tree")  ; Default archive location
  
   org-default-notes-file (concat org-directory "GTD.org")
           
   diary-file (concat org-metadir "DIARY")
  
   ; I want to hide the leading stars, and do it *exactly* in the
   ; background-color
   org-hide-leading-stars t
   org-hide-emphasis-markers t
  
   ; Which string signals that an outline is collapsed
   org-ellipsis "..."
  
   org-use-fast-todo-selection t
  
   ; We support task dependencies
   org-enforce-todo-dependencies t
   ; but relax checkbox constraints
   org-enforce-todo-checkbox-dependencies nil
  
   ; We dont do priorities
   org-enable-priority-commands nil
  
   ; Tags
   org-tags-column -110
   org-agenda-tags-column -110
  
   ;; Hide / and * markers when doing /italic/ and *bold* markup
   org-hide-emphasis-markers t
   ;; But show fancy entries
   org-pretty-entities 1
   ;; But not the sub- and superscript, cos that is bloody annoying in filenames etc.
   org-pretty-entities-include-sub-superscripts nil
  
   ; Agenda settings
   org-agenda-include-diary t
   org-agenda-start-with-log-mode t
   org-agenda-todo-ignore-scheduled "future"
  
   ; Habits
   org-habit-graph-column 100
   org-habit-show-habits-only-for-today nil
  
   ; Pressing enter on a link should activate it
   org-return-follows-link t
   org-support-shift-select (quote always)
  
   ; Refiling
   org-reverse-note-order nil    ; File at the bottom of an entry
   org-refile-allow-creating-parent-nodes (quote confirm)
   org-refile-targets (quote ((org-agenda-files :maxlevel . 10 )))
   org-refile-use-outline-path t
  
   org-agenda-dim-blocked-tasks t
   org-agenda-log-mode-items (quote (closed clock state))
   org-agenda-skip-deadline-if-done t
   org-agenda-skip-deadline-prewarning-if-scheduled t
   org-agenda-skip-scheduled-if-done t
   org-agenda-start-with-log-mode t
   org-babel-interpreters (quote ("emacs-lisp" "python" "ditaa" "sql" "sh" "R"))
   org-blank-before-new-entry (quote ((heading) (plain-list-item)))
   org-export-htmlize-output-type (quote css)
   org-fast-tag-selection-single-key (quote expert)
   org-file-apps (quote ((auto-mode . emacs) ("\\.mm\\'" . default) ("\\.x?html?\\'" . "google-chrome %s") ("\\.pdf\\'" . default)))
   org-fontify-done-headline t
   org-goto-interface (quote outline-path-completion)
   org-hierarchical-todo-statistics t
   org-provide-todo-statistics t
   org-log-into-drawer t
   org-log-redeadline (quote note)
   org-log-reschedule (quote time)
   org-modules (quote (org-info org-jsinfo org-habit org-inlinetask org-irc org-toc org-mac-iCal org-mouse))
   org-remember-default-headline ""
   org-special-ctrl-a/e t
   org-stuck-projects (quote ("-inactive/TODO" ("TODO" "WAITING") nil ""))
   org-track-ordered-property-with-tag nil
   ;; This had a serious bug in the past making it very slow, seems better now.
   org-src-fontify-natively t
  )
  
  ;;
  ;; Allow automatically handing of created/expired meta data.
  ;;
  (require 'org-expiry)
  ;; Configure it a bit to my liking
  (setq
    org-expiry-created-property-name "CREATED" ; Name of property when an item is created
    org-expiry-inactive-timestamps   t         ; Don't have everything in the agenda view
  )
  
  (defun mrb/insert-created-timestamp()
    "Insert a CREATED property using org-expiry.el for TODO entries"
    (org-expiry-insert-created)
    (org-back-to-heading)
    (org-end-of-line)
    (insert " ")
  )
    
  ;; Whenever a TODO entry is created, I want a timestamp
  ;; Advice org-insert-todo-heading to insert a created timestamp using org-expiry
  (defadvice org-insert-todo-heading (after mrb/created-timestamp-advice activate)
    "Insert a CREATED property using org-expiry.el for TODO entries"
    (mrb/insert-created-timestamp)
  )
  ;; Make it active
  (ad-activate 'org-insert-todo-heading)
  
  (require 'org-capture)
  
  (defadvice org-capture (after mrb/created-timestamp-advice activate)
    "Insert a CREATED property using org-expiry.el for TODO entries"
    ; Test if the captured entry is a TODO, if so insert the created
    ; timestamp property, otherwise ignore
    (when (member (org-get-todo-state) org-todo-keywords-1)
      (mrb/insert-created-timestamp)))
  (ad-activate 'org-capture)
  
  ;; Add feature to allow easy adding of tags in a capture window
  (defun mrb/add-tags-in-capture()
    (interactive)
    "Insert tags in a capture window without losing the point"
    (save-excursion
      (org-back-to-heading)
      (org-set-tags)))
  ;; Bind this to a reasonable key
  (define-key org-capture-mode-map "\C-c\C-t" 'mrb/add-tags-in-capture)
  
  ;; Activate Babel languages
  (require 'ob-gnuplot)
  (require 'ob-mathomatic)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t) (ditaa . t) (sql . t) (sh . t) (emacs-lisp t) (lisp t) 
     (css t) (awk t) (js t) (lisp t) (org t) (plantuml t) (gnuplot . t)))
  
  
  ; Define common tags here, so they function in all org files
  ; Make sure actions are distinguishable
  (setq org-todo-keyword-faces '(
    ("DONE"   .    (:foreground "#afd8af"     :weight bold))
    ("WAITING"   . (:foreground "dark salmon" :weight bold))
    ("CANCELLED" . (:foreground "dim gray"    :weight bold))
    ("BUY      " . (:foreground "goldenrod"   :weight bold))
  ))
  
  ; Make sure we keep a clean tag slate when changing tag state
  ; Note: caputuring does not honour this, i.e. when creating a new item.
  (setq org-todo-state-tags-triggers 
        (quote (
                ('todo ("inactive"))          ; remove inactive tags if moved to any active state
                ('done ("inactive") ("fork")) ; remove tags from any inactive state
                ("BUY"  ("buy" . t)))))       ; add buy tag when this is a buying action 
  
  
  ; Keybindings we want to have available all the time
  ; even when not in org mode.
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)
  (global-set-key "\C-cl" 'org-store-link)
  
  ; Keybindings which only make sense when having an orgmode file
  (define-key org-mode-map "\C-ct" 'org-set-tags)
  (define-key org-mode-map "\C-ce" 'org-export)
  (define-key org-mode-map [(super .)] 'org-todo)
  (defun force-org-todo()
    (interactive)
    (let ((current-prefix-arg '(64)))  ;; Triple C-u (4^3)
      (call-interactively 'org-todo))
  )
  (define-key org-mode-map [(control super .)] 'force-org-todo)
  (define-key org-agenda-mode-map [(control super .)] 'force-org-todo)
  
  (define-key org-agenda-mode-map [(super .)] 'org-agenda-todo)
  ; Map ⌘t to schedule in both task and agenda-view
  (define-key org-mode-map [(super t)] 'org-schedule)
  (define-key org-agenda-mode-map [(super t)] 'org-agenda-schedule)
  (define-key org-mode-map [(meta p)] 'org-set-property)
  (define-key org-agenda-mode-map [(meta p)] 'org-set-property)
  (define-key org-mode-map [(control super s)] 'org-save-all-org-buffers)
  
  
  ; Custom icons for the categories
  (setq org-agenda-category-icon-alist 
        '(
          ("Afspraak"      "~/.outlet/images/stock_new-meeting.png" nil nil :ascent center)
          ("Blogging"      "~/.outlet/images/edit.png" nil nil :ascent center)
          ("Cobra"         "~/.outlet/images/car.png" nil nil :ascent center)
          ("DVD"           "~/.outlet/images/media-cdrom.png" nil nil :ascent center)
          ("Emacs"         "~/.outlet/images/emacs.png" nil nil :ascent center)
          ("Finance"       "~/.outlet/images/finance.png" nil nil :ascent center)
          ("Habitat"       "~/.outlet/images/house.png" nil nil :ascent center)
          ("Habit"         "~/.outlet/images/stock_task-recurring.png" nil nil :ascent center)
          ("Hobbies"       "~/.outlet/images/hobbies.png" nil nil :ascent center)
          ("Partners"      "~/.outlet/images/partners.png" nil nil :ascent center)
          ("Task"          "~/.outlet/images/stock_todo.png" nil nil :ascent center)
          ("Org"           "~/.outlet/images/org-mode-unicorn.png" nil nil :ascent center)
          ("Statusnet"     "~/.outlet/images/statusnet.png" nil nil :ascent center)
          ("Systeem"       "~/.outlet/images/systeembeheer.png" nil nil :ascent center)
          ("Wordpress"     "~/.outlet/images/wordpress.png" nil nil :ascent center)
  ))
  ;
  ; Dynamic behaviour
  (defun gtd()
    "Start my GTD system"
    (interactive)
    (find-file org-default-notes-file)
    ;; This should not be needed, but autofill does not come on automatically
    (turn-on-auto-fill)
  )
  (global-set-key [(control c) (g)] 'gtd)
  
  
  (defun mrb/is-project-p ()
    "This function returns true if the entry is considered a project.
     A project is defined to be:
     - having a TODO keyword itself;
     - having at least one todo entry, regardless of their state."
    (let ((has-todokeyword)
          (has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      ;; both subtasks and a keyword on the container need to be present.
      (and is-a-task has-subtask)
      )
    )
  
  ; FIXME: testing for tag presence should be easier than a re-search forward
  ; FIXNE: are we not searching for all 'incomplete' type keywords here?, there must be an org function for that
  (defun mrb/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (has-next (save-excursion
                       (forward-line 1)
                       (and (< (point) subtree-end)
                            (re-search-forward "^*+ \\(TODO\\|BUY\\|WAITING\\)" subtree-end t)))))
      (if (and (mrb/is-project-p) (not has-next))
          nil ; a stuck project, has subtasks but no next task
        subtree-end)))
  
  (defun mrb/skip-non-projects ()
    "Skip trees that are not projects"
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (mrb/is-project-p)
          nil
        subtree-end)))
  
  (defun mrb/skip-projects ()
    "Skip trees that are projects"
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (mrb/is-project-p)
          subtree-end
        nil)))
  
  (defun save-containing-org-file()
    (org-save-all-org-buffers) ;; FIXME: bit over the top, no?  
  )
  (add-hook 'org-after-todo-state-change-hook 'save-containing-org-file)
  
  
  ;;
  ;; Encryption settings
  ;;
  (require 'org-crypt)
  ;; Encrypt all entries before saving
  (org-crypt-use-before-save-magic)
  (setq org-crypt-key nil)
  ;;
  ;; Exclude some tags from trickling down to their children: 
  ;;   - encrypt: why was this again?  
  ;;   - area: the tag is only valid for the parent, within an area there are tasks and projects (do I still use this?)
  ;;   - fix: the tag is typically used on the smallest units. If it is
  ;;          used on the parent, that does not directly mean that the children
  ;;          also are fixing tasks.
  (setq org-tags-exclude-from-inheritance (quote ("area" "fix" "encrypt" "crypt" "sell")))
  
  ; When in agenda mode, show the line we're working on.
  (add-hook 'org-agenda-mode-hook '(lambda () (hl-line-mode 1)))
  
  ;;
  ;; Capturing with org-capture
  ;; TODO: probably split this off into its own file
  
  ; Define the templates
  (setq org-capture-templates
        (quote (
                ("b" "Buy" 
                 entry (id "new-todo-receiver") "* BUY %? :buy:\n" :prepend t)
                ("t" "Todo" 
                 entry (id "new-todo-receiver") "* TODO %?" :prepend t)
                ("j" "Journal" 
                 entry (file+datetree (concat org-directory "journal.org")) 
                 "* ___________________________________________________________ *%U* ___\n\n%?\n" )))
  )
  
  (defun make-capture-frame ()
    "Create a new frame for org-capture to use."
    ;; Create and select the frame FIXME: the frame needs to be at least
    ;; 95 to be able to display the tag on the same line. Perhaps we
    ;; should temporarily set the tag column to something less, so we
    ;; can keep the capture window small.
    (select-frame (make-frame '((name . "capture") 
                  (width . 115) (height . 15)
                  (menu-bar-lines . 0) (tool-bar-lines . 0))))
  )
  
  (defun capture-todo ()
    "Capture a TODO item"
    (interactive)
    (make-capture-frame)
    (org-capture nil "t")
  )
  
  (defun capture-buy ()
    "Capture a BUY item"
    (interactive)
    (make-capture-frame)
    (org-capture nil "b")
  )
  
  
  (defadvice org-capture-finalize (after delete-capture-frame activate)
    "Advise org-capture-finalize to close the frame if it is the capture frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))
  
  (defadvice org-capture-destroy (after delete-capture-frame activate)
    "Advise org-capture-destroy to close the frame if it is the capture frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))
  
  ; org-capture by default splits the window, we don't want that
  (add-hook 'org-capture-mode-hook 'delete-other-windows)
  
  (defun make-journal-entry ()
    "Create a journal entry"
    (interactive)
    (org-capture nil "j")
  )
  (global-set-key "\C-cj" 'make-journal-entry)
  
  
  ;
  ; Keep an automatic history of saves with git 
  ; 
  ; FIXME: make adds/deletes work too?
  (defun git-commit ()
    ; This could be applied to other modes easily, so consider using a
    ; list of modes and defining the hook definition in a more common place.
    (when (eq major-mode 'org-mode)
      (shell-command "git commit -a -m 'Auto commit.'")))
  ;;(add-hook 'after-save-hook 'git-commit)
  
  ;
  ; When a tag change adds the waiting tag, make sure it gets scheduled
  ; 1 week from now if it is not already.
  ;
  (defun autoschedule-waiting()
    ; variable 'tags' contains the values of the tag-string
    ; If tags has the tag :waiting:, schedule this 
    ;(if includes tags "waiting")
    (message "Running my own hook")
    ;(message tags)
    (org-schedule nil (org-timestring-to-seconds "+1w"))
  )
  ; Activate it
  ;(add-hook 'org-after-tags-change-hook 'autoschedule-waiting)
  
  ;
  ; Exporting and Publishing related settings
  ;
  
  ; Apart from the normal export menu, I need something that exports
  ; just the body, so the resulting html is suitable to be used inside a
  ; blogging system like wordpress for example
  
  ; This puts the body inside a buffer called  blog-entry
  (defun org-export-body-as-html ()
    (interactive)
    (org-export-as-html 3 nil nil "blog-entry" t))
  
  ; Make sure we export in css mode, meaning no inline css crap
  (setq org-export-htmlize-output-type 'css)
  (define-key org-mode-map "\C-c\C-e" 'org-export-body-as-html)
  
  (defun org-export-body-as-html-batch ()
    "Call `org-export-as-html', may be used in batch processing as
  emacs   --batch
          --load=$HOME/lib/emacs/org.el
          --eval \"(setq org-export-headline-levels 2)\"
          --visit=MyFile --funcall org-export-body as-html-batch"
    (interactive)
    (org-export-as-html 3 nil nil nil t))
  
  ; Remove empty property drawers
  (defun mrb/org-remove-empty-propert-drawers ()
    "*Remove all empty property drawers in current file."
    (interactive)
    (unless (eq major-mode 'org-mode)
      (error "You need to turn on Org mode for this function."))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward ":PROPERTIES:" nil t)
        (save-excursion
          (org-remove-empty-drawer-at "PROPERTIES" (match-beginning 0))))))
  
  (defun mrb/org-remove-redundant-tags ()
    "Remove redundant tags of headlines in current buffer.
  
  A tag is considered redundant if it is local to a headline and
  inherited by a parent headline."
    (interactive)
    (when (eq major-mode 'org-mode)
      (save-excursion
        (org-map-entries
         '(lambda ()
            (let ((alltags (split-string (or (org-entry-get (point) "ALLTAGS") "") ":"))
                  local inherited tag)
              (dolist (tag alltags)
                (if (get-text-property 0 'inherited tag)
                    (push tag inherited) (push tag local)))
              (dolist (tag local)
                (if (member tag inherited) (org-toggle-tag tag 'off)))))
         t nil))))
  
  
  (defvar org-agenda-group-by-property nil
    "Set this in org-mode agenda views to group tasks by property")
  
  (defun org-group-bucket-items (prop items)
    (let ((buckets ()))
      (dolist (item items)
        (let* ((marker (get-text-property 0 'org-marker item))
               (pvalue (org-entry-get marker prop t))
               (cell (assoc pvalue buckets)))
          (if cell
              (setcdr cell (cons item (cdr cell)))
            (setq buckets (cons (cons pvalue (list item))
                                buckets)))))
      (setq buckets (mapcar (lambda (bucket)
                              (cons (car bucket)
                                    (reverse (cdr bucket))))
                            buckets))
      (sort buckets (lambda (i1 i2)
                      (string< (car i1) (car i2))))))
  
  (defadvice org-agenda-finalize-entries (around org-group-agenda-finalize
                                                 (list &optional nosort))
    "Prepare bucketed agenda entry lists"
    (if org-agenda-group-by-property
        ;; bucketed, handle appropriately
        (let ((text ""))
          (dolist (bucket (org-group-bucket-items
                           org-agenda-group-by-property
                           list))
            (let ((header (concat "Property "
                                  org-agenda-group-by-property
                                  " is "
                                  (or (car bucket) "<nil>") ":\n")))
              (add-text-properties 0 (1- (length header))
                                   (list 'face 'org-agenda-structure)
                                   header)
              (setq text
                    (concat text header
                            ;; recursively process
                            (let ((org-agenda-group-by-property nil))
                              (org-agenda-finalize-entries
                               (cdr bucket) nosort))
                            "\n\n"))))
          (setq ad-return-value text))
      ad-do-it))
  (ad-activate 'org-agenda-finalize-entries)
  
  ; Directly tie into the GIT org2blog repository
  (add-to-list 'load-path "~/dev/emacs/packages/org2blog/")
  (add-to-list 'load-path "~/dev/emacs/packages/xml-rpc-el/")
  (require 'org2blog-autoloads)
  
  (setq
   org2blog/wp-server-weblog-id ""
   org2blog/wp-default-title "<Untitled>"
   org2blog/wp-default-categories ""
   org2blog/wp-confirm-post t
   org2blog/wp-track-posts (list (concat org-directory "/blogs/org2blog-track.org") "To be filed properly")
  )
  
  
  ; Per blog configuration
  (setq org2blog/wp-blog-alist
        '(
          ("mrblog"
      :url "http://mrblog.nl/xmlrpc.php"
      :username "mrb"   
      :track-posts ("blogs/blogs.org" "mrblog.nl")
           )
          ("cobra"             
           :url "http://cobra.mrblog.nl/xmlrpc.php"
           :username "mrb"
           :track-posts ("blogs/blogs.org" "cobra.mrblog.nl")
           )
          ("hsd"
           :url "http://test.hsdev.com/xmlrpc.php"
           :username "mrb"
           :track-posts ("blog/blogs.org" "hsdev.com")
          )
        )
  )
  
  ;; Shorten url at point
  ;; This is a stripped down version of the code in identica-mode
  (defun mrb/ur1ca-get (api longurl)
    "Shortens url through ur1.ca free service 'as in freedom'"
    (let* ((url-request-method "POST")
          (url-request-extra-headers
           '(("Content-Type" . "application/x-www-form-urlencoded")))
          (url-request-data (concat "longurl=" (url-hexify-string longurl)))
          (buffer (url-retrieve-synchronously api)))
      (with-current-buffer buffer
        (goto-char (point-min))
        (prog1
            (if (search-forward-regexp "Your .* is: .*>\\(http://ur1.ca/[0-9A-Za-z].*\\)</a>" nil t)
                (match-string-no-properties 1)
              (error "URL shortening service failed: %s" longurl))
        (kill-buffer buffer)))))
  
  (defun mrb/shortenurl-replace-at-point ()
    "Replace the url at point with a tiny version."
    (interactive)
    (let ((url-bounds (bounds-of-thing-at-point 'url)))
      (when url-bounds
        (let ((url (mrb/ur1ca-get "http://ur1.ca" (thing-at-point 'url))))
          (when url
            (save-restriction
              (narrow-to-region (car url-bounds) (cdr url-bounds))
              (delete-region (point-min) (point-max))
              (insert url)))))))
  
  
  (defvar mrb/org-my-archive-expiry-days 365
    "The number of days after which a completed task should be auto-archived.
  This can be 0 for immediate, or a floating point value.")
  
  (defun mrb/org-my-archive-done-tasks ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (let ((done-regexp
             (concat "\\* \\(" (regexp-opt org-done-keywords) "\\) "))
            (state-regexp
             (concat "- State \"\\(" (regexp-opt org-done-keywords)
                     "\\)\"\\s-*\\[\\([^]\n]+\\)\\]")))
        (while (re-search-forward done-regexp nil t)
          (let ((end (save-excursion
                       (outline-next-heading)
                       (point)))
                begin)
            (goto-char (line-beginning-position))
            (setq begin (point))
            (when (re-search-forward state-regexp end t)
              (let* ((time-string (match-string 2))
                     (when-closed (org-parse-time-string time-string)))
                (if (>= (time-to-number-of-days
                         (time-subtract (current-time)
                                        (apply #'encode-time when-closed)))
                        mrb/org-my-archive-expiry-days)
                    (org-archive-subtree)))))))))
  
  (defalias 'archive-done-tasks 'mrb/org-my-archive-done-tasks)
  
  
  ;; Map it to Ctrl-C S in orgmode (consider a global key assignment?
  (define-key org-mode-map "\C-cs" 'mrb/shortenurl-replace-at-point)
  ;; END shorten url functionality
  
  (add-to-list 'load-path "~/dev/emacs/packages/org-bom/")
  (require 'org-bom)
  
  ;; archive entries into a date-tree
  ;; (setq org-archive-location "%s_archive::date-tree")
  (defadvice org-archive-subtree
    (around org-archive-subtree-to-data-tree activate)
    "org-archive-subtree to date-tree"
    (if
        (string= "date-tree"
                 (org-extract-archive-heading
                  (org-get-local-archive-location)))
        (let* ((dct (decode-time (org-current-time)))
               (y (nth 5 dct))
               (m (nth 4 dct))
               (d (nth 3 dct))
               (this-buffer (current-buffer))
               (location (org-get-local-archive-location))
               (afile (org-extract-archive-file location))
               (org-archive-location
                (format "%s::*** %04d-%02d-%02d %s" afile y m d
                        (format-time-string "%A" (encode-time 0 0 0 d m y)))))
          (message "afile=%s" afile)
          (unless afile
            (error "Invalid `org-archive-location'"))
          (save-excursion
            (switch-to-buffer (find-file-noselect afile))
            (org-datetree-find-year-create y)
            (org-datetree-find-month-create y m)
            (org-datetree-find-day-create y m d)
            (widen)
            (switch-to-buffer this-buffer))
          ad-do-it)
      ad-do-it))
  
  ;;
  ;; Org-mobile configuration
  (setq
   org-mobile-directory "/plato.hsdev.com:/home/mrb/data/mobileorg"              ; Remote org dir
   org-mobile-inbox-for-pull (concat org-metadir "from-mobile.org")    ; Where to place items which needs resolving
   org-mobile-force-id-on-agenda-items nil                             ; No id yet, don't see the advatage yet
   org-mobile-use-encryption nil                                       ; No encryption yet.
   org-mobile-agendas (quote all)
   org-mobile-files (quote ("~/.outlet/GTD.org" "~/.outlet/habits.org" "~/.outlet/_calendars/meetings.org"))
   org-mobile-use-encryption nil
  )
  
  ;; Define timer variables for pull and push operations
  (defvar org-mobile-push-timer nil)
  (defvar org-mobile-pull-timer nil)
  
  ;; Define notificaters
  (require 'notifications)
  
  (defun org-mobile-notify (type result)
    (notifications-notify
     :title (concat type " complete:")
     :body  (format (concat "Org-mobile-" type ": %s") result)))
  
  (defun notify-push (result) (org-mobile-notify "Push" result))
  (defun notify-pull (result) (org-mobile-notify "Pull" result))
  
  ;; Fork the work of pushing to mobile
  (defun fork-org-mobile-push()
    (async-start
     ;; What to do in the child process
     `(lambda ()
        ,(async-inject-variables "org-\\(mobile-\\|directory\\)")
        (org-mobile-push))
     
     ; What to do when it finishes
     (lambda (result)
       (notify-push result)
       (message "Push of mobile org complete"))))
  
  ;; Push to mobile when the idle timer runs out
  (defun org-mobile-push-with-delay (secs)
    (when org-mobile-push-timer
      (cancel-timer org-mobile-push-timer))
    (setq org-mobile-push-timer
          (run-with-idle-timer
           (* 1 secs) nil 'fork-org-mobile-push)))
  
  ;; After saving files, start a 30 seconds idle timer after which we
  ;; are going to push
  ;; (add-hook
  ;;  'after-save-hook
  ;;  (lambda () 
  ;;    (when (eq major-mode 'org-mode)
  ;;      (dolist (file (org-mobile-files-alist))
  ;;        (if (string= (expand-file-name (car file)) (buffer-file-name))
  ;;         (org-mobile-push-with-delay 30))))))
  
  ;; Fork the work of pushing to mobile
  (defun fork-org-mobile-pull ()
    (async-start
     ;; What to do in the child process
     `(lambda ()
        ,(async-inject-variables "org-\\(mobile-\\|directory\\)")
        (org-mobile-pull))
     
     ; What to do when it finishes
     (lambda (result)
       (notify-pull result)
       (message "Pull of mobile org complete"))))
  
  ;; Construct the name of the remote file
  (setq remote-org-mobile-file
        (file-truename
         (concat
          (file-name-as-directory org-mobile-directory)
          "mobileorg.org")))
  
  ;; Pull by monitoring the file mobile-org writes to
  (defun install-monitor (file secs)
    ;; Cancel an existing timer, if any
    (when org-mobile-pull-timer
      (cancel-timer org-mobile-pull-timer))
    ;; And set up a new one
    (setq org-mobile-pull-timer
          (run-with-timer
           0 secs
           (lambda (f p)
             ;; If the remote file has been changed within out repeat
             ;; period, we need a new copy
             (unless (< p (second (time-since (elt (file-attributes f) 5))))
               (fork-org-mobile-pull)))
           file
           secs)))
  
  ;; Install a monitor on the remote org file. Don't make the time too
  ;; short, otherwise the file might nog get pulled in.
  ;; (install-monitor remote-org-mobile-file 30)
  
  ;; Mail facilities related to org-mode
  (require 'org-mime)
  (defun mrb/mail-subtree-from-org-agenda ()
    (interactive)
    (org-agenda-goto)
    (org-mime-subtree))
  ;; Bind it to a C-c m (similar to C-x m which opens an empty mail)
  (define-key org-mode-map [(control c) m] 'org-mime-subtree)
  ;; This does not work
  ;;(define-key org-agenda-mode-map [(control c) m] 'mrb/mail-subtree-from-org-agenda)
  ;; This does
  (define-key org-agenda-mode-map "\C-cm" 'mrb/mail-subtree-from-org-agenda)
  ;;
  
  (require 'stripe-buffer)
  (defun mrb/enable-org-table-striping ()
    (interactive)
    (stripe-org-tables-enable))
  ;; TODO I want to have this in the agenda mode to
#+END_SRC
** Statusnet
Statusnet, or perhaps microblog in general settings
#+BEGIN_SRC emacs-lisp
  ; Identica comes directly from its git repository
  (add-to-list 'load-path  "~/dev/emacs/packages/identica-mode")
  (load-library "identica-mode.el")
  (require 'longlines)
  (setq 
   statusnet-server "o.mrblog.nl"
   statusnet-access-url "http://o.mrblog.nl/api/oauth/access_token"
   statusnet-authorize-url "http://o.mrblog.nl/api/oauth/authorize"
   statusnet-request-url "http://o.mrblog.nl/api/oauth/request_token"
   identica-username "mrb"
   identica-display-success-messages nil
   identica-soft-wrap-status t
   identica-status-format "%i %s %r: %t"
   identica-timer-interval 120
   identica-update-status-method (quote minibuffer)
   identica-oldest-first nil
   identica-soft-wrap-status nil
   identica-urlshortening-service (quote isgd) 
   identica-enable-striping t
   identica-enable-highlighting t
  )
  
  
  (global-set-key "\C-cip" 'identica-update-status-interactive)
  (global-set-key "\C-cid" 'identica-direct-message-interactive)
  (global-set-key "\C-cis" 'identica-shortenurl-replace-at-point)
  
  ;; I'm using a floating frame in awesome WM for dents
  (defun make-dent-frame ()
    "Create a new frame and run identica-update status."
    (interactive)
    ;; Create and select the frame
    (select-frame (make-frame '((name . "dent") 
                  (width . 80) (height . 15)
                  (menu-bar-lines . 0) (tool-bar-lines . 0))))
    ;; Capture a Todo entry, force edit-window method
    (identica-update-status 'edit-buffer)
  
    ;; Once there, make sure we're the only one
    (delete-other-windows)
  )
  
  ;; Make sure we remove our frame too
  (defadvice identica-update-status-from-edit-buffer-send (after delete-dent-frame-on-send activate)
    "Advise to close the frame"
    (if (equal "dent" (frame-parameter nil 'name))
        (delete-frame))
  )
  (defadvice identica-update-status-from-edit-buffer-cancel (after delete-dent-frame-on-cancel activate)
    "Advise to close the frame"
    (if (equal "dent" (frame-parameter nil 'name))
        (delete-frame))
  )
  (global-set-key "\C-cd" 'make-dent-frame)
  
  (provide 'statusnet)
  
#+END_SRC
** Google-map
Google map integration for Emacs
#+BEGIN_SRC emacs-lisp
  ; Directly tie into the GIT repository on this machine
  (add-to-list 'load-path "/home/mrb/dev/emacs/packages/jd-el/")
  
  (require 'google-maps)
  
  ; org-mode integration
  (require 'org-location-google-maps)
  
  (provide 'google-map-settings)
  
#+END_SRC
** OpenSCAD
OpenSCAP mode, it’s a mode that describes 3D-models
#+BEGIN_SRC emacs-lisp
  ; OpenSCAD has git repository in my dev tree
  (add-to-list 'load-path "~/dev/reprapping/openscad/contrib")
  (load "scad-mode")
  
  (provide 'openscad)
  
#+END_SRC
** LDAP
LDAP integration, mostly for address book lookups
#+BEGIN_SRC emacs-lisp
  ; LDAP integration
  
  (setq ldap-host-parameters-alist
        (quote (("ldap.hsdev.com" base "ou=addressbook,dc=hsdev,dc=com"))))
  
  (require 'ldap)
  (require 'eudc)
  
  (setq eudc-default-return-attributes nil
        eudc-strict-return-matches nil)
  
  (setq ldap-ldapsearch-args (quote ("-tt" "-LLL" "-x")))
  (setq eudc-inline-query-format '((name)
                                   (firstname)
                                   (firstname name)
                                   (email)
                                   ))
  
  
  (eudc-set-server "ldap.hsdev.com" 'ldap t)
  (setq eudc-server-hotlist '(("ldap.hsdev.com" . ldap)))
  (setq eudc-inline-expansion-servers 'hotlist)
  
  (defun enz-eudc-expand-inline()
    (interactive)
    (move-end-of-line 1)
    (insert "*")
    (unless (condition-case nil
                (eudc-expand-inline)
              (error nil))
      (backward-delete-char-untabify 1))
    )
  
  ;; Adds some hooks
  
  (eval-after-load "message"
    '(define-key message-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
  (eval-after-load "sendmail"
    '(define-key mail-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
  (eval-after-load "post"
    '(define-key post-mode-map (kbd "TAB") 'enz-eudc-expand-inline))
  
#+END_SRC
** E-Shell
A terminal in Emacs, I would like to migrate to it for all terminal
based activities, but it’s not there yet.
#+BEGIN_SRC emacs-lisp
  ;; Eshell configuration.
  
  (setq eshell-scroll-show-maximum-output t)
  (setq eshell-scroll-to-bottom-on-output t)
  
#+END_SRC
#+END_SRC
** Binding
Keyboard and mouse key bindings
#+BEGIN_SRC emacs-lisp
  ; Unset some keys to let modes explicitly set them to their value (case in point: orgmode)
  ;
  ; Unset the standard right mouse click behaviour (it kills parts of regions)
  (global-unset-key (kbd "<mouse-3>"))
  
  ;
  ; Let marks be set when shift arrowing, everybody does this
  ;
  (setq shift-select-mode t)
  (delete-selection-mode 1)
  
  ;
  ; Setup function keys the way I like it.
  
  ; Menu key does M-x, if we have it.
  (global-set-key (kbd "<apps>") 'execute-extended-command)
  (global-set-key [f1] 'help-command)
  (global-set-key [f2] 'save-buffer)
  (global-set-key [f3] 'find-file)
  
  ; Make gnome compliant
  (defun switch-full-screen ()
    (interactive)
    (shell-command "wmctrl -r :ACTIVE: -btoggle,fullscreen"))
  (global-set-key [f11] 'switch-full-screen)
  (global-set-key [XF86MenuKB] 'accelerate-menu)
  
  ; Font scaling, like in chrome
  (global-set-key [(super =)] 'text-scale-increase)
  (global-set-key [(super -)] 'text-scale-decrease)
  ; Font scaling, like in firefox
  (global-set-key [(control +)] 'text-scale-increase)
  (global-set-key [(control -)] 'text-scale-decrease)
  
  ; Line handling functions
  ;; For external keyboard FIXME: these bindings contain dead characters
  ;; if such a keyboard is used, which can be confusing.
  (global-set-key [(?\s-\§)] 'toggle-truncate-lines)
  ;; For t510 keyboard (the same place)
  (global-set-key [(super \`)] 'toggle-truncate-lines)
  
  ;; Most of the time I want return to be newline and indent
  ;; Every mode can augment this at will obviously (org-mode does, for example)
  (global-set-key (kbd "RET") 'newline-and-indent)
  
  (global-set-key [(super /)] 'comment-or-uncomment-region)
  (global-set-key [(super l)] 'goto-line)
  (global-set-key [(super s)] 'save-buffer)
  
  ; Moving back and forth in frames, disregarding frames
  (define-key global-map [(super \\)] 'next-multiframe-window)
  (define-key global-map [(super \|)] 'previous-multiframe-window)
  
  ;; Alt-Cmd left-right arrows browse through buffers within the same frame
  (global-set-key (kbd "M-s-<left>") 'previous-buffer)
  (global-set-key (kbd "M-s-<right>") 'next-buffer)
  
  ;; Ctrl Cmd moves buffers up and down in the tiling of emacs
  (global-set-key (kbd "<C-s-up>")     'buf-move-up)
  (global-set-key (kbd "<C-s-down>")   'buf-move-down)
  ;; These would conflict with awesome bindings
  ;; (global-set-key (kbd "<C-S-left>")   'buf-move-left)
  ;; (global-set-key (kbd "<C-S-right>")  'buf-move-right)
  
  (global-set-key (kbd "M-s-<left>") 'previous-buffer)
  (global-set-key (kbd "M-s-<right>") 'next-buffer)
  
  (define-key global-map [?\s-~] 'ns-prev-frame)
  ;; FIME: does not work anymore
  (global-set-key [(control tab)] 'switch-to-other-buffer)
  
  (global-set-key [(super k)] 'ido-kill-buffer)
  
  
  ;; Resizing windows
  ;; Introduce a bit of intelligence so the shrink and enlarge know what window I'm in.
  (defun xor (b1 b2)
    "Exclusive or between arguments"
    (or (and b1 b2)
        (and (not b1) (not b2))))
  
  (defun move-border-left-or-right (arg dir)
    "General function covering move-border-left and move-border-right. If DIR is
    t, then move left, otherwise move right."
    (interactive)
    (if (null arg) (setq arg 5))
    (let ((left-edge (nth 0 (window-edges))))
      (if (xor (= left-edge 0) dir)
          (shrink-window arg t)
        (enlarge-window arg t)))
    )
  
  (defun move-border-left (arg)
    (interactive "P")
    (move-border-left-or-right arg t))
  
  (defun move-border-right (arg)
    (interactive "P")
    (move-border-left-or-right arg nil))
  
  ;; Same for up and down
  (defun move-border-up-or-down (arg dir)
    "General function covering move-border-up and move-border-down. If DIR is
    t, then move up, otherwise move down."
    (interactive)
    (if (null arg) (setq arg 5))
    (let ((top-edge (nth 1 (window-edges))))
      (if (xor (= top-edge 0) dir)
          (shrink-window arg nil)
        (enlarge-window arg nil))))
  
  (defun move-border-up (arg)
    (interactive "P")
    (move-border-up-or-down arg t))
  
  (defun move-border-down (arg)
    (interactive "P")
    (move-border-up-or-down arg nil))
  
  ;; Use Super + Arrows to steer the borders
  (global-set-key [(super right)] 'move-border-right)
  (global-set-key [(super left)]  'move-border-left)
  (global-set-key [(super up)] 'move-border-up)
  (global-set-key [(super down)] 'move-border-down)
  
  
  ; cut, copy and paste with cmd-key (like on osx). 
  (global-set-key [(super z)] 'undo)
  (global-set-key [(super x)] 'clipboard-kill-region)
  (global-set-key [(super c)] 'clipboard-kill-ring-save)
  (global-set-key [(super v)] 'yank)
  (global-set-key [(super a)] 'mark-whole-buffer)
  
  (global-set-key [(kp-delete)] 'delete-char)
  
  ; Make `C-x C-m' and `C-x RET' be different (since I tend
  ; to type the latter by accident sometimes.)
  (define-key global-map [(control x) return] nil)
  
  
  (defun new-empty-buffer ()
    "Opens a new empty buffer."
    (interactive)
    (let ((buf (generate-new-buffer "untitled")))
      (switch-to-buffer buf)
      (make-frame)
      (funcall (and initial-major-mode))
      (setq buffer-offer-save t)))
  ;; note: emacs won't offer to save a buffer that's
  ;; not associated with a file,
  ;; even if buffer-modified-p is true.
  ;; One work around is to define your own my-kill-buffer function
  ;; that wraps around kill-buffer, and check on the buffer modification
  ;; status to offer save
  ;; This custome kill buffer is close-current-buffer.
  (global-set-key [(super n)] 'new-empty-buffer)
  
  ;; Bit of experimenting with keys chords to minimize thumb bending.
  (require 'key-chord)
  (key-chord-mode 1)    ;; Turn it on
  
  (key-chord-define-global "df" 'smex)        ; Pressing d and f together does the exectute extended command, smex style
  (key-chord-define-global "()"     "()\C-b") ; Brackets go together when pressed together
  
  ;; Rebind M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
  
  ;; Commands are a plenty, smex is a one
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  
  
#+END_SRC
*** Key bindings
**** Global
I am running the emacs daemon and when I quit it, I want it to quit
too. This sounds a bit counterintuitive, but as long as my emacs
config is moving and I am not proficient enough in making sure I can
apply the changed settings reliably from within emacsm, restarting
emacs is just easier. This saves me from having to kill the emacs
daemon from the terminal.

#+BEGIN_SRC emacs-lisp
(global-set-key [(control x) (control q)] 'save-buffers-kill-emacs)
#+END_SRC

** Terminal
Character encoding, commandline and emulation
#+BEGIN_SRC emacs-lisp
  ;; Full utf-8 support
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq current-language-environment "UTF-8")
  
  (defun mrb/use-utf8 ()
    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
  (add-hook 'term-exec-hook 'mrb/use-utf8)
  
  ;; Define terminal config, I prefer ansi-term
  (require 'term)
  (defun mrb/ansi-term (&optional new-buffer-name)
    "Start a terminal-emulator in a new buffer."
    (interactive) 
  
    (setq program "/bin/bash")
  
    ;; Pick the name of the new buffer.
    (setq term-ansi-buffer-name
          (if new-buffer-name
              new-buffer-name
            (if term-ansi-buffer-base-name
                (if (eq term-ansi-buffer-base-name t)
                    (file-name-nondirectory program)
                  term-ansi-buffer-base-name)
              "ansi-term")))
  
    (setq term-ansi-buffer-name (concat "*" term-ansi-buffer-name "*"))
  
    ;; In order to have more than one term active at a time
    ;; I'd like to have the term names have the *term-ansi-term<?>* form,
    ;; for now they have the *term-ansi-term*<?> form but we'll see...
  
    (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
    (setq term-ansi-buffer-name (term-ansi-make-term term-ansi-buffer-name program))
  
    (set-buffer term-ansi-buffer-name)
    (term-mode)
    (term-char-mode)
  
    ;; I wanna have find-file on C-x C-f -mm
    ;; your mileage may definitely vary, maybe it's better to put this in your
    ;; .emacs ...
  
    (term-set-escape-char ?\C-x)
  
    ;; Go there
    (switch-to-buffer term-ansi-buffer-name))
  
  ; Aliases
  (defalias 'at 'mrb/ansi-term)
  
  ;; When closing the ansi term window, close the useless buffer too
  (defadvice term-sentinel (around mrb/advice-term-sentinel (proc msg))
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))
  (ad-activate 'term-sentinel)  
#+END_SRC handling.
** Editing control

I like to do thing interactively where I can:
#+BEGIN_SRC emacs-lisp
(require 'ido)
(ido-mode t)
(setq ido-enable-flex-matching t) ;; enable fuzzy matching
(ido-everywhere)
#+END_SRC

Be smart with tabs and try to have the tab key do the sensible
thing. The list contains things the tab key should do in certain
modes if it does not already. The second part is the exclusion list
where the sensible thing the =smart-tab= mode provides is not sensible
at all.
#+BEGIN_SRC emacs-lisp
;; Do smart tabbing, this does mostly the right thing everywhere
(require 'smart-tab)
;; Make sure it does the right thing in some modes, notably erc
(setq smart-tab-completion-functions-alist
      (quote (
	      (emacs-lisp-mode . lisp-complete-symbol)
	      (text-mode . dabbrev-completion)n
	      (erc-mode . pcomplete)))
      smart-tab-disabled-major-modes
      (quote (org-mode org-agenda-mode term-mode)))

;; Enable everywhere
(global-smart-tab-mode 1)
#+END_SRC

By selecting a piece of text, wrap-region can quote or otherwise
delimit that region automatically. I enable this globally. There is
an option to configure in exception, which I have commented out as
I've found none applicable yet.
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/dev/emacs/packages/wrap-region")
(require 'wrap-region)
(wrap-region-global-mode 1)
;; (add-to-list 'wrap-region-except-modes 'conflicting-mode)
#+END_SRC
** Remote editing
#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh")
#+END_SRC

** Browser integration
My default browser, as set in the OS, is chromium. Yet, emacs needs
an explicit mention, otherwise it will start firefox. Not sure why
that is.
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function (quote browse-url-generic))
(setq browse-url-generic-program "chromium-browser")
#+END_SRC

** Messaging and chatting
*** ERC
ERC is an irc implementation within emacs.
#+BEGIN_SRC emacs-lisp
(require 'erc-services)
(and
     (require 'erc-highlight-nicknames)
     (add-to-list 'erc-modules 'highlight-nicknames)
     (erc-update-modules))
(setq
  erc-prompt-for-nickserv-password nil
  erc-hide-list '("JOIN" "PART" "QUIT")
  erc-nick '("Marcel|HSD" "Marcel||HSD")
)
#+END_SRC
*** XMPP
XMPP related settings, including interfacing it to other systems
#+BEGIN_SRC emacs-lisp
  ; Directly tie into the GIT repository on this machine if needed
  (add-to-list 'load-path "~/dev/emacs/packages/emacs-jabber/")
  (add-to-list 'load-path "~/dev/emacs/packages/emacs-jabber/compat/")
  ;;(require 'jabber-autoloads)
  (require 'jabber)
  
  ; Configuration variables
  (setq 
   jabber-show-offline-contacts nil
   jabber-default-priority 30
   jabber-alert-message-hooks (quote (jabber-message-libnotify jabber-message-echo jabber-message-scroll))
   jabber-message-alert-same-buffer nil
   jabber-roster-show-bindings nil
  )
  
  ;; Me wants the smileys too
  ;; FIXME: I suspect this makes chats annoyingly slow to type in?
  ;;(require 'autosmiley)
  ;;(add-hook 'jabber-chat-mode-hook 'autosmiley-mode)
  
  ;; Show some info in the modeline
  (jabber-mode-line-mode 1)
  
  ;; Do not steal my focus in the mini buffer
  ;; Message alert hooks
  (define-jabber-alert echo "Show a message in the echo area"
    (lambda (msg)
      (unless (minibuffer-prompt)
        (message "%s" msg))))
#+END_SRC

*** Mail
Mail configuration. 
#+BEGIN_SRC emacs-lisp
  (setq 
   ; User agent style is message mode (gnus, but independent of it)
    mail-user-agent 'message-user-agent
  
    ; Sending it
    smtpmail-default-smtp-server "localhost"
    smtpmail-smtp-service 24
    smtpmail-local-domain "hsdev.com"
    smtpmail-sendto-domain "hsdev.com"
    send-mail-function 'smtpmail-send-it                 ; This is for mail
    message-send-mail-function 'message-smtpmail-send-it ; This is for gnus
  
    ; Always put one in the Sent folder on sending
    message-default-mail-headers "Bcc: mrb+Sent@hsdev.com\n"
    mail-yank-prefix ">> "
  )
  ;; Automatically sign outgoing messages, be part of the solution here,
  ;; not the problem
  ;; TODO: where can I toggle this on/off while composing?
  ;;(setq smime-keys (quote (("marcel@hsdev.com" "~/keys/comodo-2012-06-12.pem" nil))))
  ;;(add-hook 'message-send-hook 'mml-secure-message-sign-smime)
  (setq password-cache t)            ; default is true, so no need to set this actually
  (setq password-cache-expiry 28800) ; default is 16 seconds, which is ridiculously low
  (require 'smtpmail)
  
  ;;(add-hook 'message-mode-hook 'orgstruct++-mode 'append)
  (add-hook 'message-mode-hook 'turn-on-auto-fill 'append)  
#+END_SRC
** Quantified Emacs!
Taken from sacha’s configuration, this records which keys I press in
emacs and how often I do that. This is usefull, or may be, for
decisions with respect to keyboard choices, bindings configuration
etc.
#+begin_src emacs-lisp
  (require 'keyfreq)
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)
#+end_src

** To organize and properly configura
Multiple cursors sounds interesting

#+BEGIN_SRC emacs-lisp
(require 'multiple-cursors)
#+END_SRC

License templates
#+BEGIN_SRC emacs-lisp
(require 'xlicense)
(setq license-directory "~/.emacs.d/licenses")
(add-to-list 'license-types '(agpl . "AGPL"))
#+END_SRC

Make sure erase works properly, even though I don't understand this,
apparently this is what I need.
#+BEGIN_SRC emacs-lisp
(if window-system  (normal-erase-is-backspace-mode t))
#+END_SRC
* Self configuration                                                                                 :exclude:
I have the same config file for orgmode itself
#+SETUPFILE: ~/.outlet/etc/org-config.org
  
If there is anything that needs to be configured specifically for this
file, here is the place to do it. Other than those, nothing else
should come below this point
